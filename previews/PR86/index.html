<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Documentation · TimeseriesSurrogates.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>TimeseriesSurrogates.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Documentation</a><ul class="internal"><li><a class="tocitem" href="#API"><span>API</span></a></li><li><a class="tocitem" href="#Surrogate-methods"><span>Surrogate methods</span></a></li><li><a class="tocitem" href="#Visualization"><span>Visualization</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="man/whatisasurrogate/">What is a surrogate?</a></li><li><span class="tocitem">Example applications</span><ul><li><a class="tocitem" href="constrained/randomshuffle/">Shuffle-based</a></li><li><a class="tocitem" href="constrained/fourier_surrogates/">Fourier-based</a></li><li><a class="tocitem" href="constrained/amplitude_adjusted/">Amplitude-adjusted FT</a></li><li><a class="tocitem" href="constrained/truncated_fourier_transform/">Truncated FT/AAFT</a></li><li><a class="tocitem" href="constrained/pps/">Pseudo-periodic</a></li><li><a class="tocitem" href="constrained/wls/">Wavelet-based</a></li><li><a class="tocitem" href="constrained/multidim/">Multidimensional surrogates</a></li></ul></li><li><a class="tocitem" href="man/exampleprocesses/">Utility systems</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Documentation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/TimeseriesSurrogates.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="TimeseriesSurrogates.jl"><a class="docs-heading-anchor" href="#TimeseriesSurrogates.jl">TimeseriesSurrogates.jl</a><a id="TimeseriesSurrogates.jl-1"></a><a class="docs-heading-anchor-permalink" href="#TimeseriesSurrogates.jl" title="Permalink"></a></h1><p><img src="surroplot.png" alt/></p><p><code>TimeseriesSurrogates</code> is a Julia package for generating surrogate timeseries. It is part of <a href="https://juliadynamics.github.io/JuliaDynamics/">JuliaDynamics</a>, a GitHub organization dedicated to creating high quality scientific software.</p><p>If you are new to this method of <a href="https://en.wikipedia.org/wiki/Surrogate_data_testing">surrogate time series</a>, feel free to read the <a href="man/whatisasurrogate/#What-is-a-surrogate?">What is a surrogate?</a> page.</p><h2 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h2><p>TimeseriesSurrogates.jl exports two main functions. Both of them dispatch on the chosen method, a subtype of <code>Surrogate</code>. It is recommended to standardize the signal before using these functions, i.e. subtract mean and divide by standard deviation.</p><article class="docstring"><header><a class="docstring-binding" id="TimeseriesSurrogates.surrogate" href="#TimeseriesSurrogates.surrogate"><code>TimeseriesSurrogates.surrogate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">surrogate(x, method::Surrogate [, rng]) → s</code></pre><p>Create a single surrogate timeseries <code>s</code> from <code>x</code> based on the given <code>method</code>. If you want to generate more than one surrogates from <code>x</code>, you should use <a href="#TimeseriesSurrogates.surrogenerator"><code>surrogenerator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TimeseriesSurrogates.jl/blob/1fa17de4648820c1cc91e4070bd05573db272d22/src/api.jl#L38-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeseriesSurrogates.surrogenerator" href="#TimeseriesSurrogates.surrogenerator"><code>TimeseriesSurrogates.surrogenerator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">surrogenerator(x, method::Surrogate [, rng]) → sg::SurrogateGenerator</code></pre><p>Initialize a generator that creates surrogates of <code>x</code> on demand, based on given <code>method</code>. This is efficient, because for most methods some things can be initialized and reused for every surrogate. Optionally you can provide an <code>rng::AbstractRNG</code> object that will control the random number generation and hence establish reproducibility of the generated surrogates. By default <code>Random.default_rng()</code> is used.</p><p>To generate a surrogate, call <code>sg</code> as a function with no arguments, e.g.:</p><pre><code class="language-julia hljs">sg = surrogenerator(x, method)
for i in 1:1000
    s = sg()
    # do stuff with s and or x
    result[i] = stuff
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TimeseriesSurrogates.jl/blob/1fa17de4648820c1cc91e4070bd05573db272d22/src/api.jl#L13-L30">source</a></section></article><h2 id="Surrogate-methods"><a class="docs-heading-anchor" href="#Surrogate-methods">Surrogate methods</a><a id="Surrogate-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Surrogate-methods" title="Permalink"></a></h2><ul><li><a href="#TimeseriesSurrogates.AAFT"><code>TimeseriesSurrogates.AAFT</code></a></li><li><a href="#TimeseriesSurrogates.AutoRegressive"><code>TimeseriesSurrogates.AutoRegressive</code></a></li><li><a href="#TimeseriesSurrogates.BlockShuffle"><code>TimeseriesSurrogates.BlockShuffle</code></a></li><li><a href="#TimeseriesSurrogates.CircShift"><code>TimeseriesSurrogates.CircShift</code></a></li><li><a href="#TimeseriesSurrogates.CycleShuffle"><code>TimeseriesSurrogates.CycleShuffle</code></a></li><li><a href="#TimeseriesSurrogates.IAAFT"><code>TimeseriesSurrogates.IAAFT</code></a></li><li><a href="#TimeseriesSurrogates.PseudoPeriodic"><code>TimeseriesSurrogates.PseudoPeriodic</code></a></li><li><a href="#TimeseriesSurrogates.RandomFourier"><code>TimeseriesSurrogates.RandomFourier</code></a></li><li><a href="#TimeseriesSurrogates.RandomShuffle"><code>TimeseriesSurrogates.RandomShuffle</code></a></li><li><a href="#TimeseriesSurrogates.ShuffleDimensions"><code>TimeseriesSurrogates.ShuffleDimensions</code></a></li><li><a href="#TimeseriesSurrogates.TAAFT"><code>TimeseriesSurrogates.TAAFT</code></a></li><li><a href="#TimeseriesSurrogates.TFTS"><code>TimeseriesSurrogates.TFTS</code></a></li><li><a href="#TimeseriesSurrogates.WLS"><code>TimeseriesSurrogates.WLS</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="TimeseriesSurrogates.RandomShuffle" href="#TimeseriesSurrogates.RandomShuffle"><code>TimeseriesSurrogates.RandomShuffle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RandomShuffle() &lt;: Surrogate</code></pre><p>A random constrained surrogate, generated by shifting values around.</p><p>Random shuffle surrogates preserve the mean, variance and amplitude  distribution of the original signal. Properties not preserved are <em>any  temporal information</em>, such as the power spectrum and hence linear  correlations. </p><p>The null hypothesis this method can test for is whether the data  are uncorrelated noise, possibly measured via a nonlinear function. Specifically, random shuffle surrogate can test  the null hypothesis that the original signal is produced by independent and  identically distributed random variables[^Theiler1991, ^Lancaster2018]. </p><p><em>Beware: random shuffle surrogates do not cover the case of correlated noise</em><sup class="footnote-reference"><a id="citeref-Lancaster2018" href="#footnote-Lancaster2018">[Lancaster2018]</a></sup>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TimeseriesSurrogates.jl/blob/1fa17de4648820c1cc91e4070bd05573db272d22/src/methods/randomshuffle.jl#L2-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeseriesSurrogates.BlockShuffle" href="#TimeseriesSurrogates.BlockShuffle"><code>TimeseriesSurrogates.BlockShuffle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BlockShuffle(n::Int) &lt;: Surrogate</code></pre><p>A block shuffle surrogate constructed by dividing the time series into <code>n</code> blocks of roughly equal width at random indices (end blocks are wrapped around to the start of the time series).</p><p>Block shuffle surrogates roughly preserve short-range temporal properties in the time series (e.g. correlations at lags less than the block length), but break any long-term dynamical information (e.g. correlations beyond the block length).</p><p>Hence, these surrogates can be used to test any null hypothesis aimed at comparing short-range dynamical properties versus long-range dynamical properties of the signal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TimeseriesSurrogates.jl/blob/1fa17de4648820c1cc91e4070bd05573db272d22/src/methods/large_shuffle.jl#L6-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeseriesSurrogates.CycleShuffle" href="#TimeseriesSurrogates.CycleShuffle"><code>TimeseriesSurrogates.CycleShuffle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CycleShuffle(n::Int = 7, σ = 0.5) &lt;: Surrogate</code></pre><p>Cycle shuffled surrogates<sup class="footnote-reference"><a id="citeref-Theiler1995" href="#footnote-Theiler1995">[Theiler1995]</a></sup> that identify successive local peaks in the data and shuffle the cycles in-between the peaks. Similar to <a href="#TimeseriesSurrogates.BlockShuffle"><code>BlockShuffle</code></a>, but here the &quot;blocks&quot; are defined as follows:</p><ol><li>The timeseries is smoothened via convolution with a Gaussian (<code>DSP.gaussian(n, σ)</code>).</li><li>Local maxima of the smoothened signal define the peaks, and thus the blocks in between them.</li><li>The first and last index of timeseries can never be peaks and thus signals that should have peaks very close to start or end of the timeseries may not perform well. In addition, points before the first or after the last peak are never shuffled.</li><li>The defined blocks are randomly shuffled as in <a href="#TimeseriesSurrogates.BlockShuffle"><code>BlockShuffle</code></a>.</li></ol><p>CSS are used to test the null hypothesis that the signal is generated by a periodic oscillator with no dynamical correlation between cycles, i.e. the evolution of cycles is not deterministic.</p><p>See also <a href="#TimeseriesSurrogates.PseudoPeriodic"><code>PseudoPeriodic</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TimeseriesSurrogates.jl/blob/1fa17de4648820c1cc91e4070bd05573db272d22/src/methods/large_shuffle.jl#L93-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeseriesSurrogates.CircShift" href="#TimeseriesSurrogates.CircShift"><code>TimeseriesSurrogates.CircShift</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CircShift(n) &lt;: Surrogate</code></pre><p>Surrogates that are circularly shifted versions of the original timeseries.</p><p><code>n</code> can be an integer (meaning to shift for <code>n</code> indices), or any vector of integers, which which means that each surrogate is shifted by an integer, selected randomly among the entries in <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TimeseriesSurrogates.jl/blob/1fa17de4648820c1cc91e4070bd05573db272d22/src/methods/large_shuffle.jl#L147-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeseriesSurrogates.RandomFourier" href="#TimeseriesSurrogates.RandomFourier"><code>TimeseriesSurrogates.RandomFourier</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RandomFourier(phases = true) &lt;: Surrogate</code></pre><p>A surrogate that randomizes the Fourier components of the signal in some manner. If <code>phases==true</code>, the phases are randomized, otherwise the amplitudes are randomized. <code>FT</code> is an alias for <code>RandomFourier</code>.</p><p>Random Fourier phase surrogates<sup class="footnote-reference"><a id="citeref-Theiler1991" href="#footnote-Theiler1991">[Theiler1991]</a></sup> preserve the autocorrelation function, or power spectrum, of the original signal. Random Fourier amplitude surrogates preserve the mean and autocorrelation function but do not preserve the variance of the original. Random amplitude surrogates are not common in the literature, but are provided for convenience.</p><p>Random phase surrogates can be used to test the null hypothesis that the original signal was produced by a linear Gaussian process <sup class="footnote-reference"><a id="citeref-Theiler1991" href="#footnote-Theiler1991">[Theiler1991]</a></sup>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TimeseriesSurrogates.jl/blob/1fa17de4648820c1cc91e4070bd05573db272d22/src/methods/randomfourier.jl#L2-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeseriesSurrogates.TFTS" href="#TimeseriesSurrogates.TFTS"><code>TimeseriesSurrogates.TFTS</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TFTS(fϵ::Real)</code></pre><p>A truncated Fourier transform surrogate<sup class="footnote-reference"><a id="citeref-Nakamura2006" href="#footnote-Nakamura2006">[Nakamura2006]</a></sup> (TFTS).</p><p>TFTS surrogates are generated by leaving some frequencies untouched when performing the phase shuffling step (as opposed to randomizing all frequencies, like for <a href="#TimeseriesSurrogates.RandomFourier"><code>RandomFourier</code></a> surrogates).</p><p>These surrogates were designed to deal with data with irregular fluctuations superimposed over long term trends (by preserving low frequencies)<sup class="footnote-reference"><a id="citeref-Nakamura2006" href="#footnote-Nakamura2006">[Nakamura2006]</a></sup>. Hence, TFTS surrogates can be used to test the null hypothesis that the signal is a stationary linear system generated the irregular fluctuations part of the signal<sup class="footnote-reference"><a id="citeref-Nakamura2006" href="#footnote-Nakamura2006">[Nakamura2006]</a></sup>.</p><p><strong>Controlling the truncation of the spectrum</strong></p><p>The truncation parameter <code>fϵ ∈ [-1, 0) ∪ (0, 1]</code> controls which parts of the spectrum are preserved.</p><ul><li>If <code>fϵ &gt; 0</code>, then <code>fϵ</code> indicates the ratio of high frequency domain to the entire frequency domain.   For example, <code>fϵ = 0.5</code> preserves 50% of the frequency domain (randomizing the higher   frequencies, leaving low frequencies intact).</li><li>If <code>fϵ &lt; 0</code>, then <code>fϵ</code> indicates ratio of low frequency domain to the entire frequency domain.   For example, <code>fϵ = -0.2</code> preserves 20% of the frequency domain (leaving higher frequencies intact,   randomizing the lower frequencies).</li><li>If <code>fϵ ± 1</code>, then all frequencies are randomized. The method is then equivalent to   <a href="#TimeseriesSurrogates.RandomFourier"><code>RandomFourier</code></a>.</li></ul><p>The appropriate value of <code>fϵ</code> strongly depends on the data and time series length, and must be manually determined<sup class="footnote-reference"><a id="citeref-Nakamura2006" href="#footnote-Nakamura2006">[Nakamura2006]</a></sup>, for example by comparing periodograms for the time series and the surrogates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TimeseriesSurrogates.jl/blob/1fa17de4648820c1cc91e4070bd05573db272d22/src/methods/truncated_fourier.jl#L3-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeseriesSurrogates.AAFT" href="#TimeseriesSurrogates.AAFT"><code>TimeseriesSurrogates.AAFT</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AAFT()</code></pre><p>An amplitude-adjusted-fourier-transform surrogate<sup class="footnote-reference"><a id="citeref-Theiler1991" href="#footnote-Theiler1991">[Theiler1991]</a></sup>.</p><p>AAFT have the same linear correlation, or periodogram, and also preserves the amplitude distribution of the original data.</p><p>AAFT can be used to test the null hypothesis that the data come from a monotonic nonlinear transformation of a linear Gaussian process (also called integrated white noise)<sup class="footnote-reference"><a id="citeref-Theiler1991" href="#footnote-Theiler1991">[Theiler1991]</a></sup>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TimeseriesSurrogates.jl/blob/1fa17de4648820c1cc91e4070bd05573db272d22/src/methods/aaft.jl#L2-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeseriesSurrogates.TAAFT" href="#TimeseriesSurrogates.TAAFT"><code>TimeseriesSurrogates.TAAFT</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TAAFT(fϵ)</code></pre><p>An truncated version of the amplitude-adjusted-fourier-transform surrogate<sup class="footnote-reference"><a id="citeref-Theiler1991" href="#footnote-Theiler1991">[Theiler1991]</a></sup><sup class="footnote-reference"><a id="citeref-Nakamura2006" href="#footnote-Nakamura2006">[Nakamura2006]</a></sup>.</p><p>The truncation parameter and phase randomization procedure is identical to <a href="#TimeseriesSurrogates.TFTS"><code>TFTS</code></a>, but here an additional step of rescaling back to the original data is performed. This preserves the amplitude distribution of the original data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TimeseriesSurrogates.jl/blob/1fa17de4648820c1cc91e4070bd05573db272d22/src/methods/truncated_fourier.jl#L117-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeseriesSurrogates.IAAFT" href="#TimeseriesSurrogates.IAAFT"><code>TimeseriesSurrogates.IAAFT</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IAAFT(M = 100, tol = 1e-6, W = 75)</code></pre><p>An iteratively adjusted amplitude-adjusted-fourier-transform surrogate<sup class="footnote-reference"><a id="citeref-SchreiberSchmitz1996" href="#footnote-SchreiberSchmitz1996">[SchreiberSchmitz1996]</a></sup>.</p><p>IAAFT surrogate have the same linear correlation, or periodogram, and also preserves the amplitude distribution of the original data, but are improved relative to AAFT through iterative adjustment (which runs for a maximum of <code>M</code> steps). During the iterative adjustment, the periodograms of the original signal and the surrogate are coarse-grained and the powers are averaged over <code>W</code> equal-width frequency bins. The iteration procedure ends when the relative deviation between the periodograms is less than <code>tol</code> (or when <code>M</code> is reached).</p><p>IAAFT, just as AAFT, can be used to test the null hypothesis that the data  come from a monotonic nonlinear transformation of a linear Gaussian process.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TimeseriesSurrogates.jl/blob/1fa17de4648820c1cc91e4070bd05573db272d22/src/methods/iaaft.jl#L2-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeseriesSurrogates.AutoRegressive" href="#TimeseriesSurrogates.AutoRegressive"><code>TimeseriesSurrogates.AutoRegressive</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AutoRegressive(n, method = LPCLevinson())</code></pre><p>Autoregressive surrogates of order-<code>n</code>. The autoregressive coefficients <code>φ</code> are estimated using <code>DSP.lpc(x, n, method)</code>, and thus see the documentation of DSP.jl for possible <code>method</code>s.</p><p>While these surrogates are obviously suited to test the null hypothesis whether the data are coming from a autoregressive process, the Fourier Transform-based surrogates are probably a better option. The current method is more like an explicit way to produce surrogates for the same hypothesis by fitting a model. It can be used as convient way to estimate autoregressive coefficients and automatically generate surrogates based on them.</p><p>The coefficients φ of the autoregressive fit can be found by doing</p><pre><code class="language-julia hljs">sg = surrogenerator(x, AutoRegressive(n))
φ = sg.init.φ</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TimeseriesSurrogates.jl/blob/1fa17de4648820c1cc91e4070bd05573db272d22/src/methods/ar.jl#L4-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeseriesSurrogates.PseudoPeriodic" href="#TimeseriesSurrogates.PseudoPeriodic"><code>TimeseriesSurrogates.PseudoPeriodic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PseudoPeriodic(d, τ, ρ, shift=true) &lt;: Surrogate</code></pre><p>Create surrogates suitable for pseudo-periodic signals. They retain the periodic structure of the signal, while inter-cycle dynamics that are either deterministic or correlated noise are destroyed (for appropriate <code>ρ</code> choice). Therefore these surrogates are suitable to test the null hypothesis that the signal is a periodic orbit with uncorrelated noise<sup class="footnote-reference"><a id="citeref-Small2001" href="#footnote-Small2001">[Small2001]</a></sup>.</p><p>Arguments <code>d, τ, ρ</code> are as in the paper, the embedding dimension, delay time and noise radius. The method works by performing a delay coordinates ambedding via the library <a href="https://juliadynamics.github.io/DynamicalSystems.jl/dev/embedding/reconstruction/">DynamicalSystems.jl</a>. See its documentation for choosing appropriate values for <code>d, τ</code>. For <code>ρ</code>, we have implemented the method proposed in the paper in the function <a href="#TimeseriesSurrogates.noiseradius"><code>noiseradius</code></a>.</p><p>The argument <code>shift</code> is not discussed in the paper. If <code>shift=false</code> we adjust the algorithm so that there is little phase shift between the periodic component of the original and surrogate data.</p><p>See also <a href="#TimeseriesSurrogates.CycleShuffle"><code>CycleShuffle</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TimeseriesSurrogates.jl/blob/1fa17de4648820c1cc91e4070bd05573db272d22/src/methods/pseudoperiodic.jl#L3-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeseriesSurrogates.WLS" href="#TimeseriesSurrogates.WLS"><code>TimeseriesSurrogates.WLS</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WLS(surromethod::Surrogate = IAAFT(), 
    rescale::Bool = true,
    wt::Wavelets.WT.OrthoWaveletClass = Wavelets.WT.Daubechies{16}())</code></pre><p>A wavelet surrogate generated by taking the maximal overlap discrete  wavelet transform (MODWT) of the signal, shuffling detail  coefficients at each dyadic scale using the provided <code>surromethod</code>, then taking the inverse transform to obtain a surrogate.</p><p><strong>Coefficient shuffling method</strong></p><p>In contrast to the original  implementation where IAAFT is used, you may choose to use any surrogate  method from this package to perform the randomization of the detail  coefficients at each dyadic scale. Note: The iterative procedure after  the rank ordering step (step [v] in <sup class="footnote-reference"><a id="citeref-Keylock2006" href="#footnote-Keylock2006">[Keylock2006]</a></sup>) is not performed in  this implementation.</p><p>If <code>surromethod == IAAFT()</code>, the wavelet surrogates preserves the local  mean and variance structure of the signal, but randomises nonlinear  properties of the signal (i.e. Hurst exponents)<sup class="footnote-reference"><a id="citeref-Keylock2006" href="#footnote-Keylock2006">[Keylock2006]</a></sup>. These surrogates can therefore be used to test for changes in nonlinear properties of the  original signal.</p><p>In contrast to IAAFT surrogates, the IAAFT-wavelet surrogates also  preserves nonstationarity. Using other <code>surromethod</code>s does not necessarily preserve nonstationarity.</p><p>To deal with nonstationary signals, Keylock (2006) recommends using a  wavelet with a high number of vanishing moments. Thus, the default is to use a Daubechies wavelet with 16 vanishing moments.</p><p><strong>Rescaling</strong></p><p>If <code>rescale == true</code>, then surrogate values are mapped onto the  values of the original time series, as in the <a href="#TimeseriesSurrogates.AAFT"><code>AAFT</code></a> algorithm. If <code>rescale == false</code>, surrogate values are not constrained to the  original time series values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TimeseriesSurrogates.jl/blob/1fa17de4648820c1cc91e4070bd05573db272d22/src/methods/wavelet_based.jl#L4-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeseriesSurrogates.ShuffleDimensions" href="#TimeseriesSurrogates.ShuffleDimensions"><code>TimeseriesSurrogates.ShuffleDimensions</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ShuffleDimensions()</code></pre><p>Multidimensional surrogates of input <em>datasets</em> (<code>DelayEmbeddings.Dataset</code>, which are also multidimensional) that have shuffled dimensions in each point.</p><p>These surrogates destroy the state space structure of the dataset and are thus suited to distinguish deterministic datasets from high dimensional noise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TimeseriesSurrogates.jl/blob/1fa17de4648820c1cc91e4070bd05573db272d22/src/methods/multidimensional.jl#L4-L11">source</a></section></article><h3 id="Utils"><a class="docs-heading-anchor" href="#Utils">Utils</a><a id="Utils-1"></a><a class="docs-heading-anchor-permalink" href="#Utils" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="TimeseriesSurrogates.noiseradius" href="#TimeseriesSurrogates.noiseradius"><code>TimeseriesSurrogates.noiseradius</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">noiseradius(x::AbstractVector, d::Int, τ, ρs, n = 1) → ρ</code></pre><p>Use the proposed* algorithm of<sup class="footnote-reference"><a id="citeref-Small2001" href="#footnote-Small2001">[Small2001]</a></sup> to estimate optimal <code>ρ</code> value for <a href="#TimeseriesSurrogates.PseudoPeriodic"><code>PseudoPeriodic</code></a> surrogates, where <code>ρs</code> is a vector of possible <code>ρ</code> values.</p><p>*The paper is ambiguous about exactly what to calculate. Here we count how many times we have pairs of length-2 that are identical in <code>x</code> and its surrogate, but <strong>are not</strong> also part of pairs of length-3.</p><p>This function directly returns the arg-maximum of the evaluated distribution of these counts versus <code>ρ</code>, use <code>TimeseriesSurrogates._noiseradius</code> with same arguments to get the actual distribution. <code>n</code> means to repeat τhe evaluation <code>n</code> times, which increases accuracy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TimeseriesSurrogates.jl/blob/1fa17de4648820c1cc91e4070bd05573db272d22/src/methods/pseudoperiodic.jl#L64-L78">source</a></section></article><h2 id="Visualization"><a class="docs-heading-anchor" href="#Visualization">Visualization</a><a id="Visualization-1"></a><a class="docs-heading-anchor-permalink" href="#Visualization" title="Permalink"></a></h2><p>TimeseriesSurrogates.jl provides the function <code>surroplot(x, s)</code>, which comes into scope when <code>using Plots</code>. This function is used in the example applications.</p><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Theiler1991"><a class="tag is-link" href="#citeref-Theiler1991">Theiler1991</a>J. Theiler, S. Eubank, A. Longtin, B. Galdrikian, J. Farmer, Testing for nonlinearity in time series: The method of surrogate data, Physica D 58 (1–4) (1992) 77–94.</li><li class="footnote" id="footnote-Theiler1995"><a class="tag is-link" href="#citeref-Theiler1995">Theiler1995</a>J. Theiler, On the evidence for low-dimensional chaos in an epileptic electroencephalogram, <a href="https://doi.org/10.1016/0375-9601(94)00856-K">Phys. Lett. A 196</a></li><li class="footnote" id="footnote-Theiler1991"><a class="tag is-link" href="#citeref-Theiler1991">Theiler1991</a>J. Theiler, S. Eubank, A. Longtin, B. Galdrikian, J. Farmer, Testing for nonlinearity in time series: The method of surrogate data, Physica D 58 (1–4) (1992) 77–94.</li><li class="footnote" id="footnote-Nakamura2006"><a class="tag is-link" href="#citeref-Nakamura2006">Nakamura2006</a>Nakamura, Tomomichi, Michael Small, and Yoshito Hirata. &quot;Testing for nonlinearity in irregular fluctuations with long-term trends.&quot; Physical Review E 74.2 (2006): 026205.</li><li class="footnote" id="footnote-Theiler1991"><a class="tag is-link" href="#citeref-Theiler1991">Theiler1991</a>J. Theiler, S. Eubank, A. Longtin, B. Galdrikian, J. Farmer, Testing for nonlinearity in time series: The method of surrogate data, Physica D 58 (1–4) (1992) 77–94.</li><li class="footnote" id="footnote-Theiler1991"><a class="tag is-link" href="#citeref-Theiler1991">Theiler1991</a>J. Theiler, S. Eubank, A. Longtin, B. Galdrikian, J. Farmer, Testing for nonlinearity in time series: The method of surrogate data, Physica D 58 (1–4) (1992) 77–94.</li><li class="footnote" id="footnote-Nakamura2006"><a class="tag is-link" href="#citeref-Nakamura2006">Nakamura2006</a>Nakamura, Tomomichi, Michael Small, and Yoshito Hirata. &quot;Testing for nonlinearity in irregular fluctuations with long-term trends.&quot; Physical Review E 74.2 (2006): 026205.</li><li class="footnote" id="footnote-SchreiberSchmitz1996"><a class="tag is-link" href="#citeref-SchreiberSchmitz1996">SchreiberSchmitz1996</a>T. Schreiber; A. Schmitz (1996). &quot;Improved Surrogate Data for Nonlinearity Tests&quot;. <a href="https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.77.635">Phys. Rev. Lett. 77 (4)</a></li><li class="footnote" id="footnote-Small2001"><a class="tag is-link" href="#citeref-Small2001">Small2001</a>Small et al., Surrogate test for pseudoperiodic time series data, <a href="https://doi.org/10.1103/PhysRevLett.87.188101">Physical Review Letters, 87(18)</a></li><li class="footnote" id="footnote-Keylock2006"><a class="tag is-link" href="#citeref-Keylock2006">Keylock2006</a>C.J. Keylock (2006). &quot;Constrained surrogate time series with preservation of the mean and variance structure&quot;. Phys. Rev. E. 73: 036707. doi:10.1103/PhysRevE.73.036707.</li><li class="footnote" id="footnote-Small2001"><a class="tag is-link" href="#citeref-Small2001">Small2001</a>Small et al., Surrogate test for pseudoperiodic time series data, <a href="https://doi.org/10.1103/PhysRevLett.87.188101">Physical Review Letters, 87(18)</a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="man/whatisasurrogate/">What is a surrogate? »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Sunday 16 January 2022 00:09">Sunday 16 January 2022</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
