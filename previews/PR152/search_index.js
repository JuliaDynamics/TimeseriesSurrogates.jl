var documenterSearchIndex = {"docs":
[{"location":"methods/fourier_surrogates/#Fourier-based","page":"Fourier-based","title":"Fourier-based","text":"","category":"section"},{"location":"methods/fourier_surrogates/","page":"Fourier-based","title":"Fourier-based","text":"Fourier based surrogates are a form of constrained surrogates created by taking the Fourier transform of a time series, then shuffling either the phase angles or the amplitudes of the resulting complex numbers. Then, we take the inverse Fourier transform, yielding a surrogate time series.","category":"page"},{"location":"methods/fourier_surrogates/#Random-phase","page":"Fourier-based","title":"Random phase","text":"","category":"section"},{"location":"methods/fourier_surrogates/","page":"Fourier-based","title":"Fourier-based","text":"using TimeseriesSurrogates, CairoMakie\nts = AR1() # create a realization of a random AR(1) process\nphases = true\ns = surrogate(ts, RandomFourier(phases))\n\nsurroplot(ts, s)","category":"page"},{"location":"methods/fourier_surrogates/#Random-amplitude","page":"Fourier-based","title":"Random amplitude","text":"","category":"section"},{"location":"methods/fourier_surrogates/","page":"Fourier-based","title":"Fourier-based","text":"using TimeseriesSurrogates, CairoMakie\nts = AR1() # create a realization of a random AR(1) process\nphases = false\ns = surrogate(ts, RandomFourier(phases))\n\nsurroplot(ts, s)","category":"page"},{"location":"methods/fourier_surrogates/#Partial-randomization","page":"Fourier-based","title":"Partial randomization","text":"","category":"section"},{"location":"methods/fourier_surrogates/#Without-rescaling","page":"Fourier-based","title":"Without rescaling","text":"","category":"section"},{"location":"methods/fourier_surrogates/","page":"Fourier-based","title":"Fourier-based","text":"PartialRandomization surrogates are similar to random phase surrogates,  but allows for tuning the \"degree\" of phase randomization.","category":"page"},{"location":"methods/fourier_surrogates/","page":"Fourier-based","title":"Fourier-based","text":"using TimeseriesSurrogates, CairoMakie\nts = AR1() # create a realization of a random AR(1) process\n\n# 50 % randomization of the phases\ns = surrogate(ts, PartialRandomization(0.5))\n\nsurroplot(ts, s)","category":"page"},{"location":"methods/fourier_surrogates/#With-rescaling","page":"Fourier-based","title":"With rescaling","text":"","category":"section"},{"location":"methods/fourier_surrogates/","page":"Fourier-based","title":"Fourier-based","text":"PartialRandomizationAAFT adds a rescaling step to the PartialRandomization surrogates to obtain surrogates that contain the same values as the original time series.","category":"page"},{"location":"methods/fourier_surrogates/","page":"Fourier-based","title":"Fourier-based","text":"using TimeseriesSurrogates, CairoMakie\nts = AR1() # create a realization of a random AR(1) process\n\n# 50 % randomization of the phases\ns = surrogate(ts, PartialRandomizationAAFT(0.7))\n\nsurroplot(ts, s)","category":"page"},{"location":"methods/fourier_surrogates/#Amplitude-adjusted-Fourier-transform-(AAFT)","page":"Fourier-based","title":"Amplitude adjusted Fourier transform (AAFT)","text":"","category":"section"},{"location":"methods/fourier_surrogates/","page":"Fourier-based","title":"Fourier-based","text":"using TimeseriesSurrogates, CairoMakie\nts = AR1() # create a realization of a random AR(1) process\ns = surrogate(ts, AAFT())\n\nsurroplot(ts, s)","category":"page"},{"location":"methods/fourier_surrogates/#Iterative-AAFT-(IAAFT)","page":"Fourier-based","title":"Iterative AAFT (IAAFT)","text":"","category":"section"},{"location":"methods/fourier_surrogates/","page":"Fourier-based","title":"Fourier-based","text":"The IAAFT surrogates add an iterative step to the AAFT algorithm to improve similarity of the power spectra of the original time series and the surrogates.","category":"page"},{"location":"methods/fourier_surrogates/","page":"Fourier-based","title":"Fourier-based","text":"using TimeseriesSurrogates, CairoMakie\nts = AR1() # create a realization of a random AR(1) process\ns = surrogate(ts, IAAFT())\n\nsurroplot(ts, s)","category":"page"},{"location":"collections/irregular_surrogates/#Surrogates-for-unevenly-sampled-time-series","page":"Surrogates for irregular timeseries","title":"Surrogates for unevenly sampled time series","text":"","category":"section"},{"location":"collections/irregular_surrogates/","page":"Surrogates for irregular timeseries","title":"Surrogates for irregular timeseries","text":"To derive a surrogate for unevenly sampled time series, we can use surrogate methods which which does not explicitly use the time axis like RandomShuffle or BlockShuffle, or we need to use algorithms that take the irregularity of the time axis into account.","category":"page"},{"location":"collections/irregular_surrogates/#Lomb-Scargle-based-surrogate","page":"Surrogates for irregular timeseries","title":"Lomb-Scargle based surrogate","text":"","category":"section"},{"location":"collections/irregular_surrogates/","page":"Surrogates for irregular timeseries","title":"Surrogates for irregular timeseries","text":"The IrregularLombScargle surrogate is a form of a constrained surrogate which takes the Lomb-Scargle periodogram, which works on irregularly spaced data, to derive surrogates with similar phase distribution as the original time series. This function uses the simulated annealing algorithm[SchmitzSchreiber1999] to minimize the Minkowski distance between the original periodogram and the surrogate periodogram.","category":"page"},{"location":"collections/irregular_surrogates/","page":"Surrogates for irregular timeseries","title":"Surrogates for irregular timeseries","text":"using TimeseriesSurrogates, CairoMakie, Random\n\n# Example data: random AR1 process with a time axis with unevenly \n# spaced time steps\nrng = Random.MersenneTwister(1234)\nx = AR1(n_steps = 300)\nN = length(x)\nt = (1:N) - rand(N) \n\n# Use simulated annealing based on convergence of Lomb-Scargle periodograms\n# The time series is relatively long, so set tolerance a bit higher than default.\nls = IrregularLombScargle(t, n_total = 100000, n_acc = 50000, tol = 5.0)\ns = surrogate(x, ls, rng)\n\nfig, ax = lines(t, x; label = \"original\")\nlines!(ax, t, s; label = \"surrogate\")\naxislegend(ax)\nfig","category":"page"},{"location":"collections/irregular_surrogates/","page":"Surrogates for irregular timeseries","title":"Surrogates for irregular timeseries","text":"[SchmitzSchreiber1999]: A.Schmitz T.Schreiber (1999). \"Testing for nonlinearity in unevenly sampled time series\" Phys. Rev E","category":"page"},{"location":"methods/randomshuffle/#Shuffle-based","page":"Shuffle-based","title":"Shuffle-based","text":"","category":"section"},{"location":"methods/randomshuffle/#Random-shuffle-(RS)","page":"Shuffle-based","title":"Random shuffle (RS)","text":"","category":"section"},{"location":"methods/randomshuffle/","page":"Shuffle-based","title":"Shuffle-based","text":"Randomly shuffled surrogates are simply permutations of the original time series.","category":"page"},{"location":"methods/randomshuffle/","page":"Shuffle-based","title":"Shuffle-based","text":"Thus, they break any correlations in the signal.","category":"page"},{"location":"methods/randomshuffle/","page":"Shuffle-based","title":"Shuffle-based","text":"using TimeseriesSurrogates, CairoMakie\nx = AR1() # create a realization of a random AR(1) process\ns = surrogate(x, RandomShuffle())\nsurroplot(x, s)","category":"page"},{"location":"methods/randomshuffle/#Block-shuffle-(BS)","page":"Shuffle-based","title":"Block shuffle (BS)","text":"","category":"section"},{"location":"methods/randomshuffle/","page":"Shuffle-based","title":"Shuffle-based","text":"Randomly shuffled surrogates are generated by dividing the original signal into blocks, then permuting those blocks. Block positions are randomized, and blocks at the end of the signal gets wrapped around to the start of the time series.","category":"page"},{"location":"methods/randomshuffle/","page":"Shuffle-based","title":"Shuffle-based","text":"Thus, they keep short-term correlations within blocks, but destroy any long-term dynamical information in the signal.","category":"page"},{"location":"methods/randomshuffle/","page":"Shuffle-based","title":"Shuffle-based","text":"using TimeseriesSurrogates, CairoMakie\nx = NSAR2(n_steps = 300)\n# We want to divide the signal into 8 blocks.\ns = surrogate(x, BlockShuffle(8))\np = surroplot(x, s)","category":"page"},{"location":"methods/randomshuffle/#Cycle-shuffle-(CSS)","page":"Shuffle-based","title":"Cycle shuffle (CSS)","text":"","category":"section"},{"location":"methods/randomshuffle/","page":"Shuffle-based","title":"Shuffle-based","text":"using TimeseriesSurrogates, CairoMakie\nx = random_cycles()\ns = surrogate(x, CycleShuffle())\np = surroplot(x, s)","category":"page"},{"location":"methods/randomshuffle/#Circular-shift","page":"Shuffle-based","title":"Circular shift","text":"","category":"section"},{"location":"methods/randomshuffle/","page":"Shuffle-based","title":"Shuffle-based","text":"using TimeseriesSurrogates, CairoMakie\nx = random_cycles()\ns = surrogate(x, CircShift(1:length(x)))\np = surroplot(x, s)","category":"page"},{"location":"man/exampleprocesses/#Utility-systems","page":"Utility systems","title":"Utility systems","text":"","category":"section"},{"location":"man/exampleprocesses/","page":"Utility systems","title":"Utility systems","text":"SNLST\nrandomwalk\nNSAR2\nAR1\nrandom_cycles","category":"page"},{"location":"man/exampleprocesses/#TimeseriesSurrogates.SNLST","page":"Utility systems","title":"TimeseriesSurrogates.SNLST","text":"SNLST(n_steps, x₀, k)\n\nDynamically linear process transformed by a strongly nonlinear static transformation (SNLST)[1].\n\nEquations\n\nThe system is by the following map:\n\nx(t) = k x(t-1) + a(t)\n\nwith the transformation s(t) = x(t)^3.\n\nReferences\n\n[1]: Lucio et al., Phys. Rev. E 85, 056202 (2012). https://journals.aps.org/pre/abstract/10.1103/PhysRevE.85.056202\n\n\n\n\n\n","category":"function"},{"location":"man/exampleprocesses/#TimeseriesSurrogates.randomwalk","page":"Utility systems","title":"TimeseriesSurrogates.randomwalk","text":"randomwalk(n_steps, x₀)\n\nLinear random walk (AR(1) process with a unit root)[1]. This is an example of a nonstationary linear process.\n\nReferences\n\n[1]: Lucio et al., Phys. Rev. E 85, 056202 (2012). https://journals.aps.org/pre/abstract/10.1103/PhysRevE.85.056202\n\n\n\n\n\n","category":"function"},{"location":"man/exampleprocesses/#TimeseriesSurrogates.NSAR2","page":"Utility systems","title":"TimeseriesSurrogates.NSAR2","text":"NSAR2(n_steps, x₀, x₁)\n\nCyclostationary AR(2) process[1].\n\nReferences\n\n[1]: Lucio et al., Phys. Rev. E 85, 056202 (2012). https://journals.aps.org/pre/abstract/10.1103/PhysRevE.85.056202\n\n\n\n\n\n","category":"function"},{"location":"man/exampleprocesses/#TimeseriesSurrogates.AR1","page":"Utility systems","title":"TimeseriesSurrogates.AR1","text":"AR1(; n_steps, x₀, k, rng)\n\nSimple AR(1) model given by the following map:\n\nx(t+1) = k x(t) + a(t)\n\nwhere a(t) is a draw from a normal distribution with zero mean and unit variance. x₀ sets the initial condition and k is the tunable parameter in the map. rng is a random number generator\n\n\n\n\n\n","category":"function"},{"location":"man/exampleprocesses/#TimeseriesSurrogates.random_cycles","page":"Utility systems","title":"TimeseriesSurrogates.random_cycles","text":"random_cycles(; periods=10 dt=π/20, σ = 0.05, frange = (0.8, 2.0))\n\nMake a timeseries that is composed of period full sine wave periods, each with a random frequency in the range given by frange, and added noise with std σ. The sampling time is dt.\n\n\n\n\n\n","category":"function"},{"location":"methods/pps/#Pseudo-periodic","page":"Pseudo-periodic","title":"Pseudo-periodic","text":"","category":"section"},{"location":"methods/pps/","page":"Pseudo-periodic","title":"Pseudo-periodic","text":"using TimeseriesSurrogates\nt = 0:0.05:20π\nx = @. 4 + 7cos(t) + 2cos(2t + 5π/4)\nx .+= randn(length(x))*0.2\n\n# Optimal d, τ values deduced using DelayEmbeddings.jl\nd, τ = 3, 31\n\n# For ρ you can use `noiseradius`\nρ = 0.11\n\nmethod = PseudoPeriodic(d, τ, ρ, false)\ns = surrogate(x, method)\nsurroplot(x, s)","category":"page"},{"location":"methods/multidim/#Multidimensional-surrogates","page":"Multidimensional surrogates","title":"Multidimensional surrogates","text":"","category":"section"},{"location":"methods/multidim/","page":"Multidimensional surrogates","title":"Multidimensional surrogates","text":"Multidimensional surrogates operate typically on input StateSpaceSets and output the same type.","category":"page"},{"location":"methods/multidim/#Shuffle-dimensions","page":"Multidimensional surrogates","title":"Shuffle dimensions","text":"","category":"section"},{"location":"methods/multidim/","page":"Multidimensional surrogates","title":"Multidimensional surrogates","text":"This surrogate was made to distinguish multidimensional data with structure in the state space from multidimensional noise.","category":"page"},{"location":"methods/multidim/","page":"Multidimensional surrogates","title":"Multidimensional surrogates","text":"Here is a simple application that shows that the distinction is successful for a system that we know a-priori is deterministic and has structure in the state space (a chaotic attractor).","category":"page"},{"location":"methods/multidim/","page":"Multidimensional surrogates","title":"Multidimensional surrogates","text":"using TimeseriesSurrogates\nusing DynamicalSystemsBase\nusing FractalDimensions: correlationsum\nusing CairoMakie\n\n# Create a trajectory from the towel map\nfunction towel_rule(x, p, n)\n    @inbounds x1, x2, x3 = x[1], x[2], x[3]\n    SVector( 3.8*x1*(1-x1) - 0.05*(x2+0.35)*(1-2*x3),\n    0.1*( (x2+0.35)*(1-2*x3) - 1 )*(1 - 1.9*x1),\n    3.78*x3*(1-x3)+0.2*x2 )\nend\nto = DeterministicIteratedMap(towel_rule, [0.1, -0.1, 0.1])\nX = trajectory(to, 10_000; Ttr = 100)[1]\n\ne = 10.0 .^ range(-1, 0; length = 10)\nCX = correlationsum(X, e; w = 5)\n\nle = log10.(e)\nfig, ax = lines(le, log10.(CX))\n\nsg = surrogenerator(X, ShuffleDimensions())\nfor i in 1:10\n    Z = sg()\n    CZ = correlationsum(Z, e)\n    lines!(ax, le, log.(CZ); color = (\"black\", 0.8))\nend\nax.xlabel = \"log(e)\"; ax.ylabel = \"log(C)\"\nfig","category":"page"},{"location":"methods/ppts/#Pseudo-periodic-twin-surrogates","page":"Pseudo-periodic twin","title":"Pseudo-periodic twin surrogates","text":"","category":"section"},{"location":"methods/ppts/","page":"Pseudo-periodic twin","title":"Pseudo-periodic twin","text":"using TimeseriesSurrogates, CairoMakie\n\n# Example system from the original paper\nn, Δt = 500, 0.05\nf₁, f₂ = sqrt(3), sqrt(5)\nx = [8*sin(2π*f₁*t) + 4*sin(2π*f₂*t) for t = 0:Δt:Δt*n]\n\n# Embedding parameter, neighbor threshold and noise radius\nd, τ = 2, 6\nδ = 0.15\nρ = noiseradius(x, d, τ, 0.02:0.02:0.5)\nmethod = PseudoPeriodicTwin(d, τ, δ, ρ)\n\n# Generate the surrogate, which is a `d`-dimensional dataset.\nsurr_orbit = surrogate(x, method)\n\n# Get scalar surrogate time series from first and second column.\ns1, s2 = columns(surr_orbit)\n\n# Scalar time series versus surrogate time series\nfig = Figure()\nax_ts = Axis(fig[1,1:2]; xlabel = \"time\", ylabel = \"value\")\nlines!(ax_ts, s1; color = :red)\nlines!(ax_ts, x; color = :black)\n\n# Embedding versus surrogate embedding\nX = embed(x, d, τ)\nax2 = Axis(fig[2, 1]; xlabel = \"x(t)\", ylabel = \"x(t-$τ)\")\nlines!(ax2, X[:, 1], X[:, 2]; color = :black)\nscatter!(ax2, X[:, 1], X[:, 2]; color = :black, markersize = 4)\n\nps = Axis(fig[2,2]; xlabel=  \"s(t)\", ylabel = \"s(t-$τ)\")\nlines!(ps, s1, s2; color = :red)\nscatter!(ps, s1, s2; color = :black, markersize = 4)\n\nfig","category":"page"},{"location":"methods/wls/#Wavelet-surrogates","page":"Wavelet-based","title":"Wavelet surrogates","text":"","category":"section"},{"location":"methods/wls/#WLS","page":"Wavelet-based","title":"WLS","text":"","category":"section"},{"location":"methods/wls/","page":"Wavelet-based","title":"Wavelet-based","text":"WLS surrogates are constructed by taking the maximal overlap  discrete wavelet transform (MODWT) of the signal, shuffling detail  coefficients across dyadic scales, then inverting the transform to  obtain the surrogate. ","category":"page"},{"location":"methods/wls/#Wavelet-IAAFT-(WIAAFT)-surrogates","page":"Wavelet-based","title":"Wavelet-IAAFT (WIAAFT) surrogates","text":"","category":"section"},{"location":"methods/wls/","page":"Wavelet-based","title":"Wavelet-based","text":"In Keylock (2006),  IAAFT shuffling is used, yielding surrogates that preserve the local mean and  variance of the original signal, but randomizes nonlinear properties of the signal. This also preserves nonstationarities in the signal. To construct WIAAFT surrogates, rescaling must be enabled. ","category":"page"},{"location":"methods/wls/","page":"Wavelet-based","title":"Wavelet-based","text":"Note: the final iterative procedure of the WIAAFT surrogate method, after the rescaling step,  is not performed in our current implementation, so surrogates might differ a bit from results in Keylock (2006). For now, you have to do the iterative rescaling manually if desired.. ","category":"page"},{"location":"methods/wls/","page":"Wavelet-based","title":"Wavelet-based","text":"using TimeseriesSurrogates, Random\nRandom.seed!(5040)\nn = 500\nσ = 30\nx = cumsum(randn(n)) .+ \n    [20*sin(2π/30*i) for i = 1:n] .+ \n    [20*cos(2π/90*i) for i = 1:n] .+\n    [50*sin(2π/2*i + π) for i = 1:n] .+ \n    σ .* rand(n).^2 .+ \n    [0.5*t for t = 1:n];\n\n# Rescale surrogate back to original values\nmethod = WLS(IAAFT(), rescale = true)\ns = surrogate(x, method);\np = surroplot(x, s)","category":"page"},{"location":"methods/wls/","page":"Wavelet-based","title":"Wavelet-based","text":"Even without rescaling, IAAFT shuffling also yields surrogates with local properties  very similar to the original signal.","category":"page"},{"location":"methods/wls/","page":"Wavelet-based","title":"Wavelet-based","text":"using TimeseriesSurrogates, Random\nRandom.seed!(5040)\nn = 500\nσ = 30\nx = cumsum(randn(n)) .+ \n    [20*sin(2π/30*i) for i = 1:n] .+ \n    [20*cos(2π/90*i) for i = 1:n] .+\n    [50*sin(2π/2*i + π) for i = 1:n] .+ \n    σ .* rand(n).^2 .+ \n    [0.5*t for t = 1:n];\n\n# Don't rescale back to original time series.\nmethod = WLS(IAAFT(), rescale = false)\ns = surrogate(x, method);\np = surroplot(x, s)","category":"page"},{"location":"methods/wls/#Other-shuffling-methods","page":"Wavelet-based","title":"Other shuffling methods","text":"","category":"section"},{"location":"methods/wls/","page":"Wavelet-based","title":"Wavelet-based","text":"The choice of coefficient shuffling method determines how well and  which properties of the original signal are retained by the surrogates.  There might be use cases where surrogates do not need to perfectly preserve the  autocorrelation of the original signal, so additional shuffling  methods are provided for convenience.","category":"page"},{"location":"methods/wls/","page":"Wavelet-based","title":"Wavelet-based","text":"Using random shuffling of the detail coefficients does not preserve the  autocorrelation structure of the original signal. ","category":"page"},{"location":"methods/wls/","page":"Wavelet-based","title":"Wavelet-based","text":"using TimeseriesSurrogates, Random\nRandom.seed!(5040)\nn = 500\nσ = 30\nx = cumsum(randn(n)) .+ \n    [20*sin(2π/30*i) for i = 1:n] .+ \n    [20*cos(2π/90*i) for i = 1:n] .+\n    [50*sin(2π/2*i + π) for i = 1:n] .+ \n    σ .* rand(n).^2 .+ \n    [0.5*t for t = 1:n];\n\nmethod = WLS(RandomShuffle(), rescale = false)\ns = surrogate(x, method);\np = surroplot(x, s)","category":"page"},{"location":"methods/wls/","page":"Wavelet-based","title":"Wavelet-based","text":"Block shuffling the detail coefficients better preserve local properties because the shuffling is not completely random, but still does not  preserve the autocorrelation of the original signal.","category":"page"},{"location":"methods/wls/","page":"Wavelet-based","title":"Wavelet-based","text":"using TimeseriesSurrogates, Random\nRandom.seed!(5040)\nn = 500\nσ = 30\nx = cumsum(randn(n)) .+ \n    [20*sin(2π/30*i) for i = 1:n] .+ \n    [20*cos(2π/90*i) for i = 1:n] .+\n    [50*sin(2π/2*i + π) for i = 1:n] .+ \n    σ .* rand(n).^2 .+ \n    [0.5*t for t = 1:n];\n\ns = surrogate(x, WLS(BlockShuffle(10), rescale = false));\np = surroplot(x, s)","category":"page"},{"location":"methods/wls/","page":"Wavelet-based","title":"Wavelet-based","text":"Random Fourier phase shuffling the detail coefficients does a decent job at preserving the autocorrelation.","category":"page"},{"location":"methods/wls/","page":"Wavelet-based","title":"Wavelet-based","text":"using TimeseriesSurrogates, Random\nRandom.seed!(5040)\nn = 500\nσ = 30\nx = cumsum(randn(n)) .+ \n    [20*sin(2π/30*i) for i = 1:n] .+ \n    [20*cos(2π/90*i) for i = 1:n] .+\n    [50*sin(2π/2*i + π) for i = 1:n] .+ \n    σ .* rand(n).^2 .+ \n    [0.5*t for t = 1:n];\n\ns = surrogate(x, WLS(RandomFourier(), rescale = false));\nsurroplot(x, s)","category":"page"},{"location":"methods/wls/","page":"Wavelet-based","title":"Wavelet-based","text":"To generate surrogates that preserve linear properties of the original signal, AAFT or IAAFT shuffling is required.","category":"page"},{"location":"methods/wls/#RandomCascade","page":"Wavelet-based","title":"RandomCascade","text":"","category":"section"},{"location":"methods/wls/","page":"Wavelet-based","title":"Wavelet-based","text":"RandomCascade surrogates is another wavelet-based method that uses the regular discrete wavelet transform to generate surrogates.","category":"page"},{"location":"methods/wls/","page":"Wavelet-based","title":"Wavelet-based","text":"using TimeseriesSurrogates, Random\nRandom.seed!(5040)\nn = 500\nσ = 30\nx = cumsum(randn(n)) .+ \n     [20*sin(2π/30*i) for i = 1:n] .+ \n     [20*cos(2π/90*i) for i = 1:n] .+\n     [50*sin(2π/2*i + π) for i = 1:n] .+ \n     σ .* rand(n).^2 .+ \n     [0.2*t for t = 1:n];\n\ns = surrogate(x, RandomCascade());\nsurroplot(x, s)","category":"page"},{"location":"contributor_guide/#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"contributor_guide/#Reporting-issues","page":"Contributing","title":"Reporting issues","text":"","category":"section"},{"location":"contributor_guide/","page":"Contributing","title":"Contributing","text":"If you are having issues with the code, find bugs or otherwise want to report something about the package, please submit an issue at our GitHub repository. ","category":"page"},{"location":"contributor_guide/#Feature-requests","page":"Contributing","title":"Feature requests","text":"","category":"section"},{"location":"contributor_guide/","page":"Contributing","title":"Contributing","text":"If you have requests for a new method but can't implement it yourself, you can also report it as an issue. The package developers or other volunteers might be able to help with the implementation. ","category":"page"},{"location":"contributor_guide/","page":"Contributing","title":"Contributing","text":"Please mark method requests clearly as \"Method request: my new method...\", and provide a reference to a scientific publication that outlines the algorithm. ","category":"page"},{"location":"contributor_guide/#Pull-requests","page":"Contributing","title":"Pull requests","text":"","category":"section"},{"location":"contributor_guide/","page":"Contributing","title":"Contributing","text":"Pull requests for new surrogate methods are very welcome. Ideally, your implementation should use the same API as the existing methods: ","category":"page"},{"location":"contributor_guide/","page":"Contributing","title":"Contributing","text":"Create a struct for your surrogate method, e.g. struct MyNewSurrogateMethod <: Surrogate, that contain the parameters for the method. The docstring for the method should contain a reference to scientific publications detailing the algorithm,","category":"page"},{"location":"contributor_guide/","page":"Contributing","title":"Contributing","text":"as well as the intended purpose of the method, and potential implementation details that differ from the original algorithm. ","category":"page"},{"location":"contributor_guide/","page":"Contributing","title":"Contributing","text":"Implement surrogenerator(x, method::MyNewSurrogateMethod), where you pre-compute things for efficiency and return a SurrogateGenerator instance.\nImplement the SurrogateGenerator{<:MyNewSurrogateMethod} functor that produces surrogate time series on demand. This is where the precomputed things are used, and the actual algorithm is implemented.\nThen surrogate(x, method::Surrogate) will \"just work\". ","category":"page"},{"location":"contributor_guide/","page":"Contributing","title":"Contributing","text":"If you find this approach difficult and already have a basic implementation of a new surrogate method, the package maintainers may be able to help structuring the code. Let us know in an issue or in a pull request!","category":"page"},{"location":"man/whatisasurrogate/#Crash-course-in-timeseries-surrogate-testing","page":"Crash-course in timeseries surrogate testing","title":"Crash-course in timeseries surrogate testing","text":"","category":"section"},{"location":"man/whatisasurrogate/","page":"Crash-course in timeseries surrogate testing","title":"Crash-course in timeseries surrogate testing","text":"note: Note\nThe summary here follows Sect. 7.4 from Nonlinear Dynamics by Datseris and Parlitz.","category":"page"},{"location":"man/whatisasurrogate/#What-is-a-surrogate-timeseries?","page":"Crash-course in timeseries surrogate testing","title":"What is a surrogate timeseries?","text":"","category":"section"},{"location":"man/whatisasurrogate/","page":"Crash-course in timeseries surrogate testing","title":"Crash-course in timeseries surrogate testing","text":"A surrogate of a timeseries x is another timeseries s of equal length to x. This surrogate s is generated from x so that it roughly preserves one or many pre-defined properties of x, but is otherwise randomized.","category":"page"},{"location":"man/whatisasurrogate/","page":"Crash-course in timeseries surrogate testing","title":"Crash-course in timeseries surrogate testing","text":"The upper panel in the figure below shows an example of a timeseries and one surrogate realization that preserves its both power spectrum and its amplitude distribution (histogram). Because of this preservation, the time series look similar.","category":"page"},{"location":"man/whatisasurrogate/","page":"Crash-course in timeseries surrogate testing","title":"Crash-course in timeseries surrogate testing","text":"using TimeseriesSurrogates, CairoMakie\nx = LinRange(0, 20π, 300) .+ 0.05 .* rand(300)\nts = sin.(x./rand(20:30, 300) + cos.(x))\ns = surrogate(ts, IAAFT())\n\nsurroplot(ts, s)","category":"page"},{"location":"man/whatisasurrogate/#Performing-surrogate-hypothesis-tests","page":"Crash-course in timeseries surrogate testing","title":"Performing surrogate hypothesis tests","text":"","category":"section"},{"location":"man/whatisasurrogate/","page":"Crash-course in timeseries surrogate testing","title":"Crash-course in timeseries surrogate testing","text":"A surrogate test is a statistical test of whether a given timeseries satisfies or not a given hypothesis regarding its properties or origin.","category":"page"},{"location":"man/whatisasurrogate/","page":"Crash-course in timeseries surrogate testing","title":"Crash-course in timeseries surrogate testing","text":"For example, the first surrogate methods were created to test the hypothesis, whether a given timeseries x that appears noisy may be the result of a linear stochastic process or not. If not, it may be a nonlinear process contaminated with observational noise. For the suitable hypothesis to test for, see the documentation strings of provided Surrogate methods or, even better, the review from Lancaster et al. (2018)[Lancaster2018].","category":"page"},{"location":"man/whatisasurrogate/","page":"Crash-course in timeseries surrogate testing","title":"Crash-course in timeseries surrogate testing","text":"To perform such a surrogate test, you need to:","category":"page"},{"location":"man/whatisasurrogate/","page":"Crash-course in timeseries surrogate testing","title":"Crash-course in timeseries surrogate testing","text":"Decide what hypothesis to test against\nPick a surrogate generating method that satisfies the chosen hypothesis\nPick a suitable discriminatory statistic q with q(x) ∈ Real. It must be a statistic that would obtain sufficiently different values for timeseries satisfying, or not, the chosen hypothesis.\nCompute q(s) for thousands of surrogate realizations s = surrogate(x, method)\nCompare q(x) with the distribution of q(s). If q(x) is significantly outside the e.g., 5-95 confidence interval of the distribution, the hypothesis is rejected.","category":"page"},{"location":"man/whatisasurrogate/","page":"Crash-course in timeseries surrogate testing","title":"Crash-course in timeseries surrogate testing","text":"This whole process is automated by SurrogateTest, see the example below.","category":"page"},{"location":"man/whatisasurrogate/","page":"Crash-course in timeseries surrogate testing","title":"Crash-course in timeseries surrogate testing","text":"[Lancaster2018]: Lancaster, G., Iatsenko, D., Pidde, A., Ticcinelli, V., & Stefanovska, A. (2018). Surrogate data for hypothesis testing of physical systems. Physics Reports, 748, 1–60. doi:10.1016/j.physrep.2018.06.001","category":"page"},{"location":"man/whatisasurrogate/#An-educative-example","page":"Crash-course in timeseries surrogate testing","title":"An educative example","text":"","category":"section"},{"location":"man/whatisasurrogate/","page":"Crash-course in timeseries surrogate testing","title":"Crash-course in timeseries surrogate testing","text":"Let's put everything together now to showcase how one would use this package to e.g., distinguish deterministic chaos contaminated with noise from actual stochastic timeseries, using the permutation entropy as a discriminatory statistic.","category":"page"},{"location":"man/whatisasurrogate/","page":"Crash-course in timeseries surrogate testing","title":"Crash-course in timeseries surrogate testing","text":"First, let's visualize the timeseries","category":"page"},{"location":"man/whatisasurrogate/","page":"Crash-course in timeseries surrogate testing","title":"Crash-course in timeseries surrogate testing","text":"using TimeseriesSurrogates # for surrogate tests\nusing DynamicalSystemsBase # to simulate logistic map\nusing ComplexityMeasures   # to compute permutation entropy\nusing Random: Xoshiro      # for reproducibility\nusing CairoMakie           # for plotting\n\n\n# AR1\nn = 400 # timeseries length\nrng = Xoshiro(1234567)\nx = TimeseriesSurrogates.AR1(; n_steps = n, k = 0.25, rng)\n# Logistic\nlogistic_rule(x, p, n) = @inbounds SVector(p[1]*x[1]*(1 - x[1]))\nds = DeterministicIteratedMap(logistic_rule, [0.4], [4.0])\nY, t = trajectory(ds, n-1)\ny = standardize(Y[:, 1]) .+ 0.5randn(rng, n) # 50% observational noise\n# Plot\nfig, ax1 = lines(y)\nax2, = lines(fig[2,1], x, color = Cycled(2))\nax1.title = \"deterministic + 50%noise\"\nax2.title = \"stochastic AR1\"\nfig","category":"page"},{"location":"man/whatisasurrogate/","page":"Crash-course in timeseries surrogate testing","title":"Crash-course in timeseries surrogate testing","text":"Then, let's compute surrogate distributions for both timeseries using the permutation entropy as the discriminatory statistic and RandomFourier as the surrogate generation method","category":"page"},{"location":"man/whatisasurrogate/","page":"Crash-course in timeseries surrogate testing","title":"Crash-course in timeseries surrogate testing","text":"perment(x) = entropy_normalized(SymbolicPermutation(; m = 3), x)\nmethod = RandomFourier()\n\nfig = Figure()\naxs = [Axis(fig[1, i]) for i in 1:2]\nNsurr = 1000\n\nfor (i, z) in enumerate((y, x))\n    sgen = surrogenerator(z, method)\n    qx = perment(z)\n    qs = map(perment, (sgen() for _ in 1:Nsurr))\n    hist!(axs[i], qs; label = \"pdf of q(s)\", color = Cycled(i))\n    vlines!(axs[i], qx; linewidth = 5, label = \"q(x)\", color = Cycled(3))\n    axislegend(axs[i])\nend\n\nfig","category":"page"},{"location":"man/whatisasurrogate/","page":"Crash-course in timeseries surrogate testing","title":"Crash-course in timeseries surrogate testing","text":"we clearly see that the discriminatory value for the deterministic signal is so far out of the distribution that the null hypothesis that the timeseries is stochastic can be discarded with ease.","category":"page"},{"location":"man/whatisasurrogate/","page":"Crash-course in timeseries surrogate testing","title":"Crash-course in timeseries surrogate testing","text":"This whole process can be easily automated with SurrogateTest as follows:","category":"page"},{"location":"man/whatisasurrogate/","page":"Crash-course in timeseries surrogate testing","title":"Crash-course in timeseries surrogate testing","text":"test = SurrogateTest(perment, y, method; n = 1000, rng)\np = pvalue(test)\np < 0.001  # 99.9-th quantile confidence","category":"page"},{"location":"collections/nonstationary_surrogates/#Surrogates-for-nonstationary-time-series","page":"Surrogates for nonstationary timeseries","title":"Surrogates for nonstationary time series","text":"","category":"section"},{"location":"collections/nonstationary_surrogates/","page":"Surrogates for nonstationary timeseries","title":"Surrogates for nonstationary timeseries","text":"Several of the methods provided by TimeseriesSurrogates.jl can be used to  construct surrogates for nonstationary time series, which the following examples illustrate.","category":"page"},{"location":"collections/nonstationary_surrogates/#Truncated-Fourier-surrogates","page":"Surrogates for nonstationary timeseries","title":"Truncated Fourier surrogates","text":"","category":"section"},{"location":"collections/nonstationary_surrogates/#[TFTS](@ref)","page":"Surrogates for nonstationary timeseries","title":"TFTS","text":"","category":"section"},{"location":"collections/nonstationary_surrogates/","page":"Surrogates for nonstationary timeseries","title":"Surrogates for nonstationary timeseries","text":"By retaining the lowermost frequencies of the frequency spectrum,  (TFTS) surrogates preserve long-term trends in the signals.","category":"page"},{"location":"collections/nonstationary_surrogates/","page":"Surrogates for nonstationary timeseries","title":"Surrogates for nonstationary timeseries","text":"using TimeseriesSurrogates\nn = 300; a = 0.7; A = 20; σ = 15\nx = cumsum(randn(n)) .+ [(1 + a*i) .+ A*sin(2π/10*i) for i = 1:n] .+\n    [A^2*sin(2π/2*i + π) for i = 1:n] .+ σ .* rand(n).^2;\n\n# Preserve 5 % lowermost frequencies.\nsurroplot(x, surrogate(x, TFTS(0.05)))","category":"page"},{"location":"collections/nonstationary_surrogates/#[TAAFT](@ref)","page":"Surrogates for nonstationary timeseries","title":"TAAFT","text":"","category":"section"},{"location":"collections/nonstationary_surrogates/","page":"Surrogates for nonstationary timeseries","title":"Surrogates for nonstationary timeseries","text":"Truncated AAFT surrogates (TAAFT) are similar to TFTS surrogates, but also rescales back to the original values of the signal, so that the original signal and the surrogates consists of the same values. This, however, may introduce some bias, as demonstrated below.","category":"page"},{"location":"collections/nonstationary_surrogates/","page":"Surrogates for nonstationary timeseries","title":"Surrogates for nonstationary timeseries","text":"using TimeseriesSurrogates\n\n# Example signal\nn = 300; a = 0.7; A = 20; σ = 15\nx = cumsum(randn(n)) .+ [(1 + a*i) .+ A*sin(2π/10*i) for i = 1:n] .+\n    [A^2*sin(2π/2*i + π) for i = 1:n] .+ σ .* rand(n).^2;\n\n# Preserve 5% of the power spectrum corresponding to the lowest frequencies\ns_taaft_lo = surrogate(x, TAAFT(0.05))\nsurroplot(x, s_taaft_lo)","category":"page"},{"location":"collections/nonstationary_surrogates/","page":"Surrogates for nonstationary timeseries","title":"Surrogates for nonstationary timeseries","text":"using TimeseriesSurrogates\n\n# Example signal\nn = 300; a = 0.7; A = 20; σ = 15\nx = cumsum(randn(n)) .+ [(1 + a*i) .+ A*sin(2π/10*i) for i = 1:n] .+\n    [A^2*sin(2π/2*i + π) for i = 1:n] .+ σ .* rand(n).^2;\n\n# Preserve 20% of the power spectrum corresponding to the highest frequencies\ns_taaft_hi = surrogate(x, TAAFT(-0.2))\nsurroplot(x, s_taaft_hi)","category":"page"},{"location":"collections/nonstationary_surrogates/#Truncated-FT-surrogates-with-trend-removal/addition","page":"Surrogates for nonstationary timeseries","title":"Truncated FT surrogates with trend removal/addition","text":"","category":"section"},{"location":"collections/nonstationary_surrogates/","page":"Surrogates for nonstationary timeseries","title":"Surrogates for nonstationary timeseries","text":"One solution is to combine truncated Fourier surrogates with detrending/retrending.  For time series with strong trends, Lucio et al. (2012)[Lucio2012] proposes variants  of the truncated Fourier-based surrogates wherein the trend is removed prior to surrogate generation, and then added to the surrogate again after it has been generated.  This yields surrogates quite similar to those obtained when using truncated Fourier  surrogates (e.g. TFTS), but reducing the effects of endpoint mismatch that  affects regular truncated Fourier transform based surrogates.","category":"page"},{"location":"collections/nonstationary_surrogates/","page":"Surrogates for nonstationary timeseries","title":"Surrogates for nonstationary timeseries","text":"In principle, any trend could be removed/added to the signal. For now, the only  option is to remove a best-fit linear trend obtained by ordinary least squares  regression.","category":"page"},{"location":"collections/nonstationary_surrogates/#[TFTD](@ref)","page":"Surrogates for nonstationary timeseries","title":"TFTD","text":"","category":"section"},{"location":"collections/nonstationary_surrogates/","page":"Surrogates for nonstationary timeseries","title":"Surrogates for nonstationary timeseries","text":"The TFTD surrogate is a random Fourier surrogate where  the lowest frequencies are preserved during surrogate generation, and a  linear trend is removed during preprosessing and added again after the  surrogate has been generated. The TFTD surrogates do a decent  job at preserving long term trends.","category":"page"},{"location":"collections/nonstationary_surrogates/","page":"Surrogates for nonstationary timeseries","title":"Surrogates for nonstationary timeseries","text":"using TimeseriesSurrogates\n\n# Example signal\nn = 300; a = 0.7; A = 20; σ = 15\nx = cumsum(randn(n)) .+ [(1 + a*i) .+ A*sin(2π/10*i) for i = 1:n] .+\n    [A^2*sin(2π/2*i + π) for i = 1:n] .+ σ .* rand(n).^2;\n\ns = surrogate(x, TFTDRandomFourier(true, 0.02))\nsurroplot(x, s)","category":"page"},{"location":"collections/nonstationary_surrogates/","page":"Surrogates for nonstationary timeseries","title":"Surrogates for nonstationary timeseries","text":"[Lucio2012]: Lucio, J. H., Valdés, R., & Rodríguez, L. R. (2012). Improvements to surrogate data methods for nonstationary time series. Physical Review E, 85(5), 056202.","category":"page"},{"location":"collections/nonstationary_surrogates/#[TFTDAAFT](@ref)","page":"Surrogates for nonstationary timeseries","title":"TFTDAAFT","text":"","category":"section"},{"location":"collections/nonstationary_surrogates/","page":"Surrogates for nonstationary timeseries","title":"Surrogates for nonstationary timeseries","text":"The detrend-retrend extension of TAAFT is the TFTDAAFT method. The TFTDAAFT method adds a rescaling step to the TFTD method, ensuring that the surrogate and the original time series consist of the same values. Long-term trends in the data are also decently preserved by TFTDAAFT, but like TFTDAAFT, there is some bias.","category":"page"},{"location":"collections/nonstationary_surrogates/","page":"Surrogates for nonstationary timeseries","title":"Surrogates for nonstationary timeseries","text":"using TimeseriesSurrogates\n\n# Example signal\nn = 300; a = 0.7; A = 20; σ = 15\nx = cumsum(randn(n)) .+ [(1 + a*i) .+ A*sin(2π/10*i) for i = 1:n] .+\n    [A^2*sin(2π/2*i + π) for i = 1:n] .+ σ .* rand(n).^2;\n\n# Keep 2 % of lowermost frequencies.\ns = surrogate(x, TFTDAAFT(0.02))\nsurroplot(x, s)","category":"page"},{"location":"collections/nonstationary_surrogates/#[TFTDIAAFT](@ref)","page":"Surrogates for nonstationary timeseries","title":"TFTDIAAFT","text":"","category":"section"},{"location":"collections/nonstationary_surrogates/","page":"Surrogates for nonstationary timeseries","title":"Surrogates for nonstationary timeseries","text":"TFTDIAAFT[Lucio2012] surrogates are similar to TFTDAAFT surrogates, but the TFTDIAAFT[Lucio2012] method also uses an iterative process to better match the power spectra of the original signal and the surrogate (analogous to how the IAAFT method improves upon the AAFT method).","category":"page"},{"location":"collections/nonstationary_surrogates/","page":"Surrogates for nonstationary timeseries","title":"Surrogates for nonstationary timeseries","text":"using TimeseriesSurrogates\n\n# Example signal\nn = 300; a = 0.7; A = 20; σ = 15\nx = cumsum(randn(n)) .+ [(1 + a*i) .+ A*sin(2π/10*i) for i = 1:n] .+\n    [A^2*sin(2π/2*i + π) for i = 1:n] .+ σ .* rand(n).^2;\n\n# Keep 5% of lowermost frequences\ns = surrogate(x, TFTDIAAFT(0.05))\nsurroplot(x, s)","category":"page"},{"location":"#TimeseriesSurrogates.jl","page":"Documentation","title":"TimeseriesSurrogates.jl","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"(Image: )","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"TimeseriesSurrogates is a Julia package for generating surrogate timeseries. It is part of JuliaDynamics, a GitHub organization dedicated to creating high quality scientific software.","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"If you are new to this method of surrogate timeseries, feel free to read the Crash-course into timeseries surrogate tests page.","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"Please note that timeseries surrogates should not be confused with surrogate models, such as those provided by Surrogates.jl.","category":"page"},{"location":"#Installation","page":"Documentation","title":"Installation","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"TimeseriesSurrogates.jl is a registered Julia package. To install the latest version, run the following code:","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"import Pkg; Pkg.add(\"TimeseriesSurrogates\")","category":"page"},{"location":"#API","page":"Documentation","title":"API","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"TimeseriesSurrogates.jl API is composed by four names: surrogate, surrogenerator, SurrogateTest, and pvalue. They dispatch on the method to generate surrogates, which is a subtype of Surrogate.","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"It is recommended to standardize the signal before using these functions, i.e. subtract mean and divide by standard deviation. The function standardize does this.","category":"page"},{"location":"#Generating-surrogates","page":"Documentation","title":"Generating surrogates","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"surrogate\nsurrogenerator","category":"page"},{"location":"#TimeseriesSurrogates.surrogate","page":"Documentation","title":"TimeseriesSurrogates.surrogate","text":"surrogate(x, method::Surrogate [, rng]) → s\n\nCreate a single surrogate timeseries s from x based on the given method. If you want to generate multiple surrogates from x, you should use surrogenerator for better performance.\n\n\n\n\n\n","category":"function"},{"location":"#TimeseriesSurrogates.surrogenerator","page":"Documentation","title":"TimeseriesSurrogates.surrogenerator","text":"surrogenerator(x, method::Surrogate [, rng]) → sgen::SurrogateGenerator\n\nInitialize a generator that creates surrogates of x on demand, based on the given method. This is more efficient than surrogate, because for most methods some things can be initialized and reused for every surrogate. Optionally you can provide an rng::AbstractRNG object that will control the random number generation and hence establish reproducibility of the generated surrogates. By default Random.default_rng() is used.\n\nThe generated surrogates overwrite, in-place, a common vector container. Use copy if you need to actually store multiple surrogates.\n\nTo generate a surrogate, call sgen as a function with no arguments, e.g.:\n\nsgen = surrogenerator(x, method)\ns = sgen()\n\nYou can use the generator syntax of Julia to map over surrogates generated by sg. For example, let q be a function returning a discriminatory statistic. To test some null hypothesis with TimeseriesSurrogates.jl you'd do\n\nusing TimeseriesSurrogates\nq, x # inputs\nmethod = RandomFourier() # some example method\nsgen = surrogenerator(x, method)\nsiter = (sgen() for _ in 1:1000)\nqx = q(x)\nqs = map(q, siter)\n# compare `qx` with quantiles\nusing Statistics: quantile\nq01, q99 = quantile(qs, [0.01, 0.99])\nq01 ≤ qx ≤ q99 # if false, hypothesis can be rejected!\n\n\n\n\n\n","category":"function"},{"location":"#Hypothesis-testing","page":"Documentation","title":"Hypothesis testing","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"SurrogateTest\npvalue(::SurrogateTest)","category":"page"},{"location":"#TimeseriesSurrogates.SurrogateTest","page":"Documentation","title":"TimeseriesSurrogates.SurrogateTest","text":"SurrogateTest(f::Function, x, method::Surrogate; kwargs...) → test\n\nInitialize a surrogate test for input data x, which can be used in pvalue. The tests requires as input a function f that given a timeseries (like x) it outputs a real number, and a method of how to generate surrogates. f is the function that computes the discriminatory statistic.\n\nOnce called with pvalue, the test stores the real value rval and surrogate values vals of the discriminatory statistic in the fields rval, vals respectively.\n\nSurrogateTest automates the process described in the documentation page Performing surrogate hypothesis tests.\n\nSurrogateTest subtypes HypothesisTest and is part of the StatsAPI.jl interface.\n\nKeywords\n\nrng = Random.default_rng(): a random number generator.\nn::Int = 10_000: how many surrogates to generate and compute f on.\nthreaded = true: Whether to parallelize looping over surrogate computations in pvalue to the available threads (Threads.nthreads()).\n\n\n\n\n\n","category":"type"},{"location":"#StatsAPI.pvalue-Tuple{SurrogateTest}","page":"Documentation","title":"StatsAPI.pvalue","text":"pvalue(test::SurrogateTest; tail = :left)\n\nReturn the p-value corresponding to the given SurrogateTest, optionally specifying what kind of tail test to do (one of :left, :right, :both).\n\nFor SurrogateTest, the p-value is simply the proportion of surrogate statistics that exceed (for tail = :right) or subseed (tail = :left) the discriminatory statistic computed from the input data.\n\nThe default value of tail assumes that the surrogate data are expected to have higher discriminatory statistic values. This is the case for statistics that quantify entropy. For statistics that quantify autocorrelation, use tail = :right instead.\n\n\n\n\n\n","category":"method"},{"location":"#Surrogate-methods","page":"Documentation","title":"Surrogate methods","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"Surrogate","category":"page"},{"location":"#TimeseriesSurrogates.Surrogate","page":"Documentation","title":"TimeseriesSurrogates.Surrogate","text":"Supertype of all surrogate methods.\n\n\n\n\n\n","category":"type"},{"location":"","page":"Documentation","title":"Documentation","text":"Order = [:type]","category":"page"},{"location":"#Shuffle-based","page":"Documentation","title":"Shuffle-based","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"RandomShuffle\nBlockShuffle\nCycleShuffle\nCircShift","category":"page"},{"location":"#TimeseriesSurrogates.RandomShuffle","page":"Documentation","title":"TimeseriesSurrogates.RandomShuffle","text":"RandomShuffle() <: Surrogate\n\nA random constrained surrogate, generated by shifting values around.\n\nRandom shuffle surrogates preserve the mean, variance and amplitude  distribution of the original signal. Properties not preserved are any  temporal information, such as the power spectrum and hence linear  correlations. \n\nThe null hypothesis this method can test for is whether the data  are uncorrelated noise, possibly measured via a nonlinear function. Specifically, random shuffle surrogate can test  the null hypothesis that the original signal is produced by independent and  identically distributed random variables[^Theiler1991, ^Lancaster2018]. \n\nBeware: random shuffle surrogates do not cover the case of correlated noise[Lancaster2018]. \n\n[Theiler1991]: J. Theiler, S. Eubank, A. Longtin, B. Galdrikian, J. Farmer, Testing for nonlinearity in time series: The method of surrogate data, Physica D 58 (1–4) (1992) 77–94.\n\n\n\n\n\n","category":"type"},{"location":"#TimeseriesSurrogates.BlockShuffle","page":"Documentation","title":"TimeseriesSurrogates.BlockShuffle","text":"BlockShuffle(n::Int; shift = false)\n\nA block shuffle surrogate constructed by dividing the time series into n blocks of roughly equal width at random indices (end blocks are wrapped around to the start of the time series).\n\nIf shift is true, then the input signal is circularly shifted by a  random number of steps prior to picking blocks.\n\nBlock shuffle surrogates roughly preserve short-range temporal properties in the time series (e.g. correlations at lags less than the block length), but break any long-term dynamical information (e.g. correlations beyond the block length).\n\nHence, these surrogates can be used to test any null hypothesis aimed at comparing short-range dynamical properties versus long-range dynamical properties of the signal.\n\n\n\n\n\n","category":"type"},{"location":"#TimeseriesSurrogates.CycleShuffle","page":"Documentation","title":"TimeseriesSurrogates.CycleShuffle","text":"CycleShuffle(n::Int = 7, σ = 0.5)\n\nCycle shuffled surrogates[Theiler1994] that identify successive local peaks in the data and shuffle the cycles in-between the peaks. Similar to BlockShuffle, but here the \"blocks\" are defined as follows:\n\nThe timeseries is smoothened via convolution with a Gaussian (DSP.gaussian(n, σ)).\nLocal maxima of the smoothened signal define the peaks, and thus the blocks in between them.\nThe first and last index of timeseries can never be peaks and thus signals that should have peaks very close to start or end of the timeseries may not perform well. In addition, points before the first or after the last peak are never shuffled.\nThe defined blocks are randomly shuffled as in BlockShuffle.\n\nCSS are used to test the null hypothesis that the signal is generated by a periodic oscillator with no dynamical correlation between cycles, i.e. the evolution of cycles is not deterministic.\n\nSee also PseudoPeriodic.\n\n[Theiler1994]: J. Theiler, On the evidence for low-dimensional chaos in an epileptic electroencephalogram, Phys. Lett. A 196\n\n\n\n\n\n","category":"type"},{"location":"#TimeseriesSurrogates.CircShift","page":"Documentation","title":"TimeseriesSurrogates.CircShift","text":"CircShift(n)\n\nSurrogates that are circularly shifted versions of the original timeseries.\n\nn can be an integer (the surrogate is the original time series shifted  by n indices), or any vector of integers, which which means that each  surrogate is shifted by an integer selected randomly among the entries in n.\n\n\n\n\n\n","category":"type"},{"location":"#Fourier-based","page":"Documentation","title":"Fourier-based","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"RandomFourier\nTFTDRandomFourier\nPartialRandomization\nPartialRandomizationAAFT\nAAFT\nTAAFT\nIAAFT","category":"page"},{"location":"#TimeseriesSurrogates.RandomFourier","page":"Documentation","title":"TimeseriesSurrogates.RandomFourier","text":"RandomFourier(phases = true)\n\nA surrogate that randomizes the Fourier components of the signal in some manner. If phases==true, the phases are randomized, otherwise the amplitudes are randomized. FT is an alias for RandomFourier.\n\nRandom Fourier phase surrogates[Theiler1991] preserve the autocorrelation function, or power spectrum, of the original signal. Random Fourier amplitude surrogates preserve the mean and autocorrelation function but do not preserve the variance of the original. Random amplitude surrogates are not common in the literature, but are provided for convenience.\n\nRandom phase surrogates can be used to test the null hypothesis that the original signal was produced by a linear Gaussian process [Theiler1991].\n\n[Theiler1991]: J. Theiler, S. Eubank, A. Longtin, B. Galdrikian, J. Farmer, Testing for nonlinearity in time series: The method of surrogate data, Physica D 58 (1–4) (1992) 77–94.\n\n\n\n\n\n","category":"type"},{"location":"#TimeseriesSurrogates.TFTDRandomFourier","page":"Documentation","title":"TimeseriesSurrogates.TFTDRandomFourier","text":"TFTD(phases::Bool = true, fϵ = 0.05)\n\nThe TFTDRandomFourier (or just TFTD for short) surrogate was proposed by Lucio et al. (2012)[Lucio2012] as a combination of truncated Fourier surrogates[Nakamura2006] (TFTS) and detrend-retrend surrogates.\n\nThe TFTD part of the name comes from the fact that it uses a combination of truncated Fourier transforms (TFT) and de-trending and re-trending (D) the time series before and after surrogate generation. Hence, it can be used to generate surrogates also from (strongly) nonstationary time series.\n\nImplementation details\n\nHere, a best-fit linear trend is removed/added from the signal prior to and after generating the random Fourier signal. In principle, any trend can be removed, but so far, we only provide the linear option.\n\nSee also: TFTDAAFT, TFTDIAAFT.\n\n[Nakamura2006]: Nakamura, Tomomichi, Michael Small, and Yoshito Hirata. \"Testing for nonlinearity in irregular fluctuations with long-term trends.\" Physical Review E 74.2 (2006): 026205.\n\n[Lucio2012]: Lucio, J. H., Valdés, R., & Rodríguez, L. R. (2012). Improvements to surrogate data methods for nonstationary time series. Physical Review E, 85(5), 056202.\n\n\n\n\n\n","category":"type"},{"location":"#TimeseriesSurrogates.PartialRandomization","page":"Documentation","title":"TimeseriesSurrogates.PartialRandomization","text":"PartialRandomization(α = 0.5)\n\nPartialRandomization surrogates[Ortega1998] are similar to RandomFourier phase  surrogates, but during the phase randomization step, instead of drawing phases from [0, 2π], phases are drawn from [0, 2π]*α, where α ∈ [0, 1]. The authors refers to α as the  \"degree\" of phase randomization, where α = 0 means 0 % randomization and  α = 1 means 100 % randomization.\n\n[Ortega1998]: Ortega, Guillermo J.; Louis, Enrique (1998). Smoothness Implies Determinism in Time Series: A Measure Based Approach. Physical Review Letters, 81(20), 4345–4348. doi:10.1103/PhysRevLett.81.4345\n\n\n\n\n\n","category":"type"},{"location":"#TimeseriesSurrogates.PartialRandomizationAAFT","page":"Documentation","title":"TimeseriesSurrogates.PartialRandomizationAAFT","text":"PartialRandomizationAAFT(α = 0.5)\n\nPartialRandomizationAAFF surrogates are similar to PartialRandomization  surrogates[Ortega1998], but adds a rescaling step, so that the surrogate has  the same values as the original time series (analogous to the rescaling done for AAFT surrogates). Partial randomization surrogates have, to the package authors' knowledge, not been  published in scientific literature.\n\n[Ortega1998]: Ortega, Guillermo J.; Louis, Enrique (1998). Smoothness Implies Determinism in Time Series: A Measure Based Approach. Physical Review Letters, 81(20), 4345–4348. doi:10.1103/PhysRevLett.81.4345\n\n\n\n\n\n","category":"type"},{"location":"#TimeseriesSurrogates.AAFT","page":"Documentation","title":"TimeseriesSurrogates.AAFT","text":"AAFT()\n\nAn amplitude-adjusted-fourier-transform (AAFT) surrogate[Theiler1991].\n\nAAFT surrogates have the same linear correlation, or periodogram, and also preserves the amplitude distribution of the original data.\n\nAAFT surrogates can be used to test the null hypothesis that the data come from a monotonic nonlinear transformation of a linear Gaussian process (also called integrated white noise)[Theiler1991].\n\n[Theiler1991]: J. Theiler, S. Eubank, A. Longtin, B. Galdrikian, J. Farmer, Testing for nonlinearity in time series: The method of surrogate data, Physica D 58 (1–4) (1992) 77–94.\n\n\n\n\n\n","category":"type"},{"location":"#TimeseriesSurrogates.TAAFT","page":"Documentation","title":"TimeseriesSurrogates.TAAFT","text":"TAAFT(fϵ)\n\nAn truncated version of the amplitude-adjusted-fourier-transform surrogate[Theiler1991][Nakamura2006].\n\nThe truncation parameter and phase randomization procedure is identical to TFTS, but here an additional step of rescaling back to the original data is performed. This preserves the amplitude distribution of the original data.\n\n[Theiler1991]: J. Theiler, S. Eubank, A. Longtin, B. Galdrikian, J. Farmer, Testing for nonlinearity in time series: The method of surrogate data, Physica D 58 (1–4) (1992) 77–94.\n\n[Nakamura2006]: Nakamura, Tomomichi, Michael Small, and Yoshito Hirata. \"Testing for nonlinearity in irregular fluctuations with long-term trends.\" Physical Review E 74.2 (2006): 026205.\n\n\n\n\n\n","category":"type"},{"location":"#TimeseriesSurrogates.IAAFT","page":"Documentation","title":"TimeseriesSurrogates.IAAFT","text":"IAAFT(M = 100, tol = 1e-6, W = 75)\n\nAn iteratively adjusted amplitude-adjusted-fourier-transform surrogate[SchreiberSchmitz1996].\n\nIAAFT surrogates have the same linear correlation, or periodogram, and also preserves the amplitude distribution of the original data, but are improved relative to AAFT through iterative adjustment (which runs for a maximum of M steps). During the iterative adjustment, the periodograms of the original signal and the surrogate are coarse-grained and the powers are averaged over W equal-width frequency bins. The iteration procedure ends when the relative deviation between the periodograms is less than tol (or when M is reached).\n\nIAAFT, just as AAFT, can be used to test the null hypothesis that the data come from a monotonic nonlinear transformation of a linear Gaussian process.\n\n[SchreiberSchmitz1996]: T. Schreiber; A. Schmitz (1996). \"Improved Surrogate Data for Nonlinearity Tests\". Phys. Rev. Lett. 77 (4)\n\n\n\n\n\n","category":"type"},{"location":"#Non-stationary","page":"Documentation","title":"Non-stationary","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"TFTS\nTFTD\nTFTDAAFT\nTFTDIAAFT","category":"page"},{"location":"#TimeseriesSurrogates.TFTS","page":"Documentation","title":"TimeseriesSurrogates.TFTS","text":"TFTS(fϵ::Real)\n\nA truncated Fourier transform surrogate[Nakamura2006] (TFTS).\n\nTFTS surrogates are generated by leaving some frequencies untouched when performing the phase shuffling step (as opposed to randomizing all frequencies, like for RandomFourier surrogates).\n\nThese surrogates were designed to deal with data with irregular fluctuations superimposed over long term trends (by preserving low frequencies)[Nakamura2006]. Hence, TFTS surrogates can be used to test the null hypothesis that the signal is a stationary linear system generated the irregular fluctuations part of the signal[Nakamura2006].\n\nControlling the truncation of the spectrum\n\nThe truncation parameter fϵ ∈ [-1, 0) ∪ (0, 1] controls which parts of the spectrum are preserved.\n\nIf fϵ > 0, then fϵ indicates the ratio of high frequency domain to the entire frequency domain.   For example, fϵ = 0.5 preserves 50% of the frequency domain (randomizing the higher   frequencies, leaving low frequencies intact).\nIf fϵ < 0, then fϵ indicates ratio of low frequency domain to the entire frequency domain.   For example, fϵ = -0.2 preserves 20% of the frequency domain (leaving higher frequencies intact,   randomizing the lower frequencies).\nIf fϵ ± 1, then all frequencies are randomized. The method is then equivalent to   RandomFourier.\n\nThe appropriate value of fϵ strongly depends on the data and time series length, and must be manually determined[Nakamura2006], for example by comparing periodograms for the time series and the surrogates.\n\n[Nakamura2006]: Nakamura, Tomomichi, Michael Small, and Yoshito Hirata. \"Testing for nonlinearity in irregular fluctuations with long-term trends.\" Physical Review E 74.2 (2006): 026205.\n\n\n\n\n\n","category":"type"},{"location":"#TimeseriesSurrogates.TFTD","page":"Documentation","title":"TimeseriesSurrogates.TFTD","text":"TFTD(phases::Bool = true, fϵ = 0.05)\n\nThe TFTDRandomFourier (or just TFTD for short) surrogate was proposed by Lucio et al. (2012)[Lucio2012] as a combination of truncated Fourier surrogates[Nakamura2006] (TFTS) and detrend-retrend surrogates.\n\nThe TFTD part of the name comes from the fact that it uses a combination of truncated Fourier transforms (TFT) and de-trending and re-trending (D) the time series before and after surrogate generation. Hence, it can be used to generate surrogates also from (strongly) nonstationary time series.\n\nImplementation details\n\nHere, a best-fit linear trend is removed/added from the signal prior to and after generating the random Fourier signal. In principle, any trend can be removed, but so far, we only provide the linear option.\n\nSee also: TFTDAAFT, TFTDIAAFT.\n\n[Nakamura2006]: Nakamura, Tomomichi, Michael Small, and Yoshito Hirata. \"Testing for nonlinearity in irregular fluctuations with long-term trends.\" Physical Review E 74.2 (2006): 026205.\n\n[Lucio2012]: Lucio, J. H., Valdés, R., & Rodríguez, L. R. (2012). Improvements to surrogate data methods for nonstationary time series. Physical Review E, 85(5), 056202.\n\n\n\n\n\n","category":"type"},{"location":"#TimeseriesSurrogates.TFTDAAFT","page":"Documentation","title":"TimeseriesSurrogates.TFTDAAFT","text":"TFTDAAFT(fϵ = 0.05)\n\nTFTDAAFT[Lucio2012] are similar to TFTD surrogates, but also re-scales back to the original values of the time series. fϵ ∈ (0, 1] is the fraction of the powerspectrum corresponding to the lowermost frequencies to be preserved.\n\nSee also: TFTD, TFTDIAAFT.\n\n[Lucio2012]: Lucio, J. H., Valdés, R., & Rodríguez, L. R. (2012). Improvements to surrogate data methods for nonstationary time series. Physical Review E, 85(5), 056202.\n\n\n\n\n\n","category":"type"},{"location":"#TimeseriesSurrogates.TFTDIAAFT","page":"Documentation","title":"TimeseriesSurrogates.TFTDIAAFT","text":"TFTDIAAFT(fϵ = 0.05; M::Int = 100, tol::Real = 1e-6, W::Int = 75)\n\nTFTDIAAFT[Lucio2012] are similar to TFTDAAFT, but adds an iterative procedure to better match the periodograms of the surrogate and the original time series, analogously to how IAAFT improves upon AAFT.\n\nfϵ ∈ (0, 1] is the fraction of the powerspectrum corresponding to the lowermost frequencies to be preserved. M is the maximum number of iterations. tol is the desired maximum relative tolerance between power spectra. W is the number of bins into which the periodograms are binned when comparing across iterations.\n\nSee also: TFTD, TFTDAAFT.\n\n[Lucio2012]: Lucio, J. H., Valdés, R., & Rodríguez, L. R. (2012). Improvements to surrogate data methods for nonstationary time series. Physical Review E, 85(5), 056202.\n\n\n\n\n\n","category":"type"},{"location":"#Pseudo-periodic","page":"Documentation","title":"Pseudo-periodic","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"PseudoPeriodic\nPseudoPeriodicTwin","category":"page"},{"location":"#TimeseriesSurrogates.PseudoPeriodic","page":"Documentation","title":"TimeseriesSurrogates.PseudoPeriodic","text":"PseudoPeriodic(d, τ, ρ, shift = true)\n\nCreate surrogates suitable for pseudo-periodic signals. They retain the periodic structure of the signal, while inter-cycle dynamics that are either deterministic or correlated noise are destroyed (for appropriate ρ choice). Therefore these surrogates are suitable to test the null hypothesis that the signal is a periodic orbit with uncorrelated noise[Small2001].\n\nArguments d, τ, ρ are as in the paper, the embedding dimension, delay time and noise radius. The method works by performing a delay coordinates embedding from DelayEmbeddings.jl (see that docs for choosing appropriate d, τ). For ρ, we have implemented the method proposed in the paper in the function noiseradius.\n\nThe argument shift is not discussed in the paper. If shift=false we adjust the algorithm so that there is little phase shift between the periodic component of the original and surrogate data.\n\nSee also CycleShuffle.\n\n[Small2001]: Small et al., Surrogate test for pseudoperiodic time series data, Physical Review Letters, 87(18)\n\n\n\n\n\n","category":"type"},{"location":"#TimeseriesSurrogates.PseudoPeriodicTwin","page":"Documentation","title":"TimeseriesSurrogates.PseudoPeriodicTwin","text":"PseudoPeriodicTwin(d::Int, τ::Int, δ = 0.2, ρ = 0.1, metric = Euclidean())\nPseudoPeriodicTwin(δ = 0.2, ρ = 0.1, metric = Euclidean())\n\nA pseudoperiodic twin surrogate[Miralles2015], which is a fusion of the twin surrogate[Thiel2006] and the pseudo-periodic surrogate[Small2001].\n\nInput parameters\n\nA delay reconstruction of the input timeseries is constructed using embedding dimension d and embedding delay τ. The threshold δ ∈ (0, 1] determines which points are \"close\" (neighbors) or not, and is expressed as a fraction of the attractor diameter, as determined by the input data. The authors of the original twin surrogate paper recommend 0.05 ≤ δ ≤ 0.2[Thiel2006].\n\nIf you have pre-embedded your timeseries, and timeseries is already a ::StateSpaceSet, use the three-argument constructor (so that no delay reconstruction is performed). If you want a surrogate for a scalar-valued timeseries, use the five-argument constructor to also provide the embedding delay τ and embedding dimension d.\n\nNull hypothesis\n\nPseudo-periodic twin surrogates generate signals similar to the original data if the original signal is (quasi-)periodic. If the original signal is not (quasi-)periodic, then these surrogates will have different recurrence plots than the original signal, but preserve the overall shape of the attractor. Thus, PseudoPeriodicTwin surrogates can be used to test null hypothesis that the observed timeseries (or orbit) is consistent with a quasi-periodic orbit[Miralles2015].\n\nReturns\n\nA d-dimensional surrogate orbit (a StateSpaceSet) is returned. Sample the first column of this dataset if a scalar-valued surrogate is desired.\n\n[Small2001]: Small et al., Surrogate test for pseudoperiodic timeseries data, Physical Review Letters, 87(18)\n\n[Thiel2006]: Thiel, Marco, et al. \"Twin surrogates to test for complex synchronisation.\" EPL (Europhysics Letters) 75.4 (2006): 535.\n\n[Miralles2015]: Miralles, R., et al. \"Characterization of the complexity in short oscillating timeseries: An application to seismic airgun detonations.\" The Journal of the Acoustical Society of America 138.3 (2015): 1595-1603.\n\n\n\n\n\n","category":"type"},{"location":"#Wavelet-based","page":"Documentation","title":"Wavelet-based","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"WLS\nRandomCascade","category":"page"},{"location":"#TimeseriesSurrogates.WLS","page":"Documentation","title":"TimeseriesSurrogates.WLS","text":"WLS(shufflemethod::Surrogate = IAAFT();\n    f::Union{Nothing, Function} = Statistics.cor,\n    rescale::Bool = true,\n    wt::Wavelets.WT.OrthoWaveletClass = Wavelets.WT.Daubechies{16}())\n\nA wavelet surrogate generated by the following procedure:\n\nCompute the wavelet transform of the signal. This results in a set of   detail coefficients over a set of dyadic scales. As in Keylock (2006),   we here use the maximal overlap discrete wavelet transform, or MODWT,  so that the number of coefficients at each scale are the same.\nShuffle the detail coefficients at each dyadic scale using the   provided shufflemethod. See \"Shuffling methods\" below for alternatives.\nApply the inverse wavelet transform to the shuffled detail coefficients   to obtain a surrogate time series.\n\nShuffling methods\n\nYou may choose to use any surrogate from this package to perform the  randomization of the detail coefficients at each dyadic scale.\n\nThe following methods have been discussed in the literature (more may exist): \n\nRandom permutations of wavelet coefficients within each scale (Breakspear et al., 2003). To get this behaviour, use WLS(x, RandomShuffle(), rescale = false, f = nothing).\nCyclic rotation of wavelet coefficients within each scale (Breakspear et al., 2003).  To get this behaviour, use WLS(x, Circshift(1:length(x)), rescale = false, f = nothing).\nBlock resampling of wavelet coefficients within each scale (Breakspear et al., 2003). To get this behaviour, use WLS(x, BlockShuffle(nblocks, randomize = true), rescale = false, f = nothing).\nIAAFT resampling of wavelet coefficients within each scale (Keylock, 2006). To get this behaviour, use WLS(x, IAAFT(), rescale = true, f = Statistics.cor).   This method preserves the local mean and variance structure of the signal, but    randomises nonlinear properties of the signal (i.e. Hurst exponents)[Keylock2006].    These surrogates can therefore be used to test for changes in nonlinear properties    of the original signal. In contrast to IAAFT surrogates, the IAAFT-wavelet surrogates    also preserves nonstationarity. Using other shufflemethods does not necessarily   preserve nonstationarity. To deal with nonstationary signals, Keylock (2006) recommends    using a wavelet with a high number of vanishing moments. Thus, our default is to   use a Daubechies wavelet with 16 vanishing moments. Note: The iterative procedure after    the rank ordering step (step [v] in [Keylock2006]) is not performed in    this implementation.\n\nThe default method and parameters replicate the behaviour of Keylock (2006)'s IAAFT  wavelet surrogates.\n\nError minimization\n\nFor the IAAFT approach introduced in Keylock (2006), detail coefficients  at each level are circularly rotated to minimize an error function. The methods  introduced in Breakspear et al. (2003) do not apply this error minimization.\n\nIn our implementation, you can turn this option on/off using the f parameter of  the WLS constructor. If f = nothing turns off error minization. If f is set  to a two-argument function that computes some statistic, for example  f = Statistics.cor, then detail coefficients at each scale are circularly  rotated until that function is maximized (and hence the \"error\" minimized).  If you want to minimize some error function, then instead provide an appropriate  transform of your function. For example, if using the root mean squared deviation, define rmsd_inv(x, y) = 1 - StatsBase.rmsd(x, y) and set f = rmsd_inv.\n\nRescaling\n\nIf rescale == true, then surrogate values are mapped onto the  values of the original time series, as in the AAFT algorithm. If rescale == false, surrogate values are not constrained to the  original time series values. If AAFT or IAAFT shuffling  is used, rescale should be set to true. For other methods, it does not  necessarily need to be.\n\n[Breakspear2003]: Breakspear, M., Brammer, M., & Robinson, P. A. (2003). Construction of multivariate surrogate sets from nonlinear data using the wavelet transform. Physica D: Nonlinear Phenomena, 182(1-2), 1-22.\n\n[Keylock2006]: C.J. Keylock (2006). \"Constrained surrogate time series with preservation of the mean and variance structure\". Phys. Rev. E. 73: 036707. doi:10.1103/PhysRevE.73.036707.\n\n\n\n\n\n","category":"type"},{"location":"#TimeseriesSurrogates.RandomCascade","page":"Documentation","title":"TimeseriesSurrogates.RandomCascade","text":"RandomCascade(paddingmode::String = \"zeros\")\n\nA random cascade multifractal wavelet surrogate (Paluš, 2008)[Paluš2008].\n\nIf the input signal length is not a power of 2, the signal must be  padded before the surrogate is constructed. paddingmode determines  how the signal is padded. Currently supported padding modes: \"zeros\". The final surrogate (constructed from the padded signal) is subset to match the length of the original signal.\n\nRandom cascade surrogate preserve multifractal properties of the input  time series, that is, interactions among dyadic scales and nonlinear  dependencies[Paluš2008].\n\n[Paluš2008]: Paluš, Milan (2008). Bootstrapping Multifractals: Surrogate Data from Random Cascades on Wavelet Dyadic Trees. Physical Review Letters, 101(13), 134101–. doi:10.1103/PhysRevLett.101.134101\n\n\n\n\n\n","category":"type"},{"location":"#Other","page":"Documentation","title":"Other","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"AutoRegressive\nShuffleDimensions\nIrregularLombScargle","category":"page"},{"location":"#Utilities","page":"Documentation","title":"Utilities","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"noiseradius","category":"page"},{"location":"#TimeseriesSurrogates.noiseradius","page":"Documentation","title":"TimeseriesSurrogates.noiseradius","text":"noiseradius(x::AbstractVector, d::Int, τ, ρs, n = 1) → ρ\n\nUse the proposed* algorithm of[Small2001] to estimate optimal ρ value for PseudoPeriodic surrogates, where ρs is a vector of possible ρ values. *The paper is ambiguous about exactly what to calculate. Here we count how many times we have pairs of length-2 that are identical in x and its surrogate, but are not also part of pairs of length-3.\n\nThis function directly returns the arg-maximum of the evaluated distribution of these counts versus ρ, use TimeseriesSurrogates._noiseradius with same arguments to get the actual distribution. n means to repeat τhe evaluation n times, which increases accuracy.\n\n[Small2001]: Small et al., Surrogate test for pseudoperiodic time series data, Physical Review Letters, 87(18)\n\n\n\n\n\n","category":"function"},{"location":"#Visualization","page":"Documentation","title":"Visualization","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"TimeseriesSurrogates.jl has defined a simple function surroplot(x, s). This comes into scope when using Makie (you also need a plotting backend). This functionality requires you to be using Julia 1.9 or later versions.","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"Example:","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"using TimeseriesSurrogates\nusing CairoMakie\nx = AR1() # create a realization of a random AR(1) process\nfig = surroplot(x, AAFT())\nsave(\"surroplot.png\", fig); # hide","category":"page"},{"location":"#Citing","page":"Documentation","title":"Citing","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"Please use the following BiBTeX entry, or DOI, to cite TimeseriesSurrogates.jl:","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"DOI: https://doi.org/10.21105/joss.04414","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"BiBTeX:","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"@article{TimeseriesSurrogates.jl,\n    doi = {10.21105/joss.04414},\n    url = {https://doi.org/10.21105/joss.04414},\n    year = {2022},\n    publisher = {The Open Journal},\n    volume = {7},\n    number = {77},\n    pages = {4414},\n    author = {Kristian Agasøster Haaga and George Datseris},\n    title = {TimeseriesSurrogates.jl: a Julia package for generating surrogate data},\n    journal = {Journal of Open Source Software}\n}","category":"page"}]
}
