<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Documentation · TimeseriesSurrogates.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>TimeseriesSurrogates.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Documentation</a><ul class="internal"><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#API"><span>API</span></a></li><li><a class="tocitem" href="#Surrogate-methods"><span>Surrogate methods</span></a></li><li><a class="tocitem" href="#Visualization"><span>Visualization</span></a></li><li><a class="tocitem" href="#Citing"><span>Citing</span></a></li></ul></li><li><a class="tocitem" href="man/whatisasurrogate/">Crash-course in timeseries surrogate testing</a></li><li><span class="tocitem">Example applications</span><ul><li><a class="tocitem" href="methods/randomshuffle/">Shuffle-based</a></li><li><a class="tocitem" href="methods/fourier_surrogates/">Fourier-based</a></li><li><a class="tocitem" href="methods/wls/">Wavelet-based</a></li><li><a class="tocitem" href="methods/pps/">Pseudo-periodic</a></li><li><a class="tocitem" href="methods/ppts/">Pseudo-periodic twin</a></li><li><a class="tocitem" href="methods/multidim/">Multidimensional surrogates</a></li><li><a class="tocitem" href="collections/irregular_surrogates/">Surrogates for irregular timeseries</a></li><li><a class="tocitem" href="collections/nonstationary_surrogates/">Surrogates for nonstationary timeseries</a></li></ul></li><li><a class="tocitem" href="man/exampleprocesses/">Utility systems</a></li><li><a class="tocitem" href="contributor_guide/">Contributing</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Documentation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/TimeseriesSurrogates.jl/blob/main/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="TimeseriesSurrogates.jl"><a class="docs-heading-anchor" href="#TimeseriesSurrogates.jl">TimeseriesSurrogates.jl</a><a id="TimeseriesSurrogates.jl-1"></a><a class="docs-heading-anchor-permalink" href="#TimeseriesSurrogates.jl" title="Permalink"></a></h1><p><img src="surroplot.png" alt/></p><p><code>TimeseriesSurrogates</code> is a Julia package for generating surrogate timeseries. It is part of <a href="https://juliadynamics.github.io/JuliaDynamics/">JuliaDynamics</a>, a GitHub organization dedicated to creating high quality scientific software.</p><p>If you are new to this method of surrogate timeseries, feel free to read the <a href="man/whatisasurrogate/#Crash-course-in-timeseries-surrogate-testing">Crash-course in timeseries surrogate testing</a> page.</p><p>Please note that timeseries surrogates should not be confused with <a href="https://en.wikipedia.org/wiki/Surrogate_model">surrogate models</a>, such as those provided by <a href="https://github.com/SciML/Surrogates.jl">Surrogates.jl</a>.</p><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><p>TimeseriesSurrogates.jl is a registered Julia package. To install the latest version, run the following code:</p><pre><code class="language-julia hljs">import Pkg; Pkg.add(&quot;TimeseriesSurrogates&quot;)</code></pre><h2 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h2><p>TimeseriesSurrogates.jl API is composed by four names: <a href="#TimeseriesSurrogates.surrogate"><code>surrogate</code></a>, <a href="#TimeseriesSurrogates.surrogenerator"><code>surrogenerator</code></a>, <a href="#TimeseriesSurrogates.SurrogateTest"><code>SurrogateTest</code></a>, and <a href="#StatsAPI.pvalue-Tuple{SurrogateTest}"><code>pvalue</code></a>. They dispatch on the method to generate surrogates, which is a subtype of <a href="#TimeseriesSurrogates.Surrogate"><code>Surrogate</code></a>.</p><p>It is recommended to standardize the signal before using these functions, i.e. subtract mean and divide by standard deviation. The function <code>standardize</code> does this.</p><h3 id="Generating-surrogates"><a class="docs-heading-anchor" href="#Generating-surrogates">Generating surrogates</a><a id="Generating-surrogates-1"></a><a class="docs-heading-anchor-permalink" href="#Generating-surrogates" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="TimeseriesSurrogates.surrogate" href="#TimeseriesSurrogates.surrogate"><code>TimeseriesSurrogates.surrogate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">surrogate(x, method::Surrogate [, rng]) → s</code></pre><p>Create a single surrogate timeseries <code>s</code> from <code>x</code> based on the given <code>method</code>. If you want to generate multiple surrogates from <code>x</code>, you should use <a href="#TimeseriesSurrogates.surrogenerator"><code>surrogenerator</code></a> for better performance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TimeseriesSurrogates.jl/blob/6a1cec87b0133b3e1351b81a74806bafe3a55fb5/src/core/api.jl#L60-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeseriesSurrogates.surrogenerator" href="#TimeseriesSurrogates.surrogenerator"><code>TimeseriesSurrogates.surrogenerator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">surrogenerator(x, method::Surrogate [, rng]) → sgen::SurrogateGenerator</code></pre><p>Initialize a generator that creates surrogates of <code>x</code> on demand, based on the given <code>method</code>. This is more efficient than <a href="#TimeseriesSurrogates.surrogate"><code>surrogate</code></a>, because for most methods some things can be initialized and reused for every surrogate. Optionally you can provide an <code>rng::AbstractRNG</code> object that will control the random number generation and hence establish reproducibility of the generated surrogates. By default <code>Random.default_rng()</code> is used.</p><p>The generated surrogates overwrite, in-place, a common vector container. Use <code>copy</code> if you need to actually store multiple surrogates.</p><p>To generate a surrogate, call <code>sgen</code> as a function with no arguments, e.g.:</p><pre><code class="language-julia hljs">sgen = surrogenerator(x, method)
s = sgen()</code></pre><p>You can use the generator syntax of Julia to map over surrogates generated by <code>sg</code>. For example, let <code>q</code> be a function returning a discriminatory statistic. To test some null hypothesis with TimeseriesSurrogates.jl you&#39;d do</p><pre><code class="language-julia hljs">using TimeseriesSurrogates
q, x # inputs
method = RandomFourier() # some example method
sgen = surrogenerator(x, method)
siter = (sgen() for _ in 1:1000)
qx = q(x)
qs = map(q, siter)
# compare `qx` with quantiles
using Statistics: quantile
q01, q99 = quantile(qs, [0.01, 0.99])
q01 ≤ qx ≤ q99 # if false, hypothesis can be rejected!</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TimeseriesSurrogates.jl/blob/6a1cec87b0133b3e1351b81a74806bafe3a55fb5/src/core/api.jl#L14-L52">source</a></section></article><h3 id="Hypothesis-testing"><a class="docs-heading-anchor" href="#Hypothesis-testing">Hypothesis testing</a><a id="Hypothesis-testing-1"></a><a class="docs-heading-anchor-permalink" href="#Hypothesis-testing" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="TimeseriesSurrogates.SurrogateTest" href="#TimeseriesSurrogates.SurrogateTest"><code>TimeseriesSurrogates.SurrogateTest</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SurrogateTest(f::Function, x, method::Surrogate; kwargs...) → test</code></pre><p>Initialize a surrogate test for input data <code>x</code>, which can be used in <a href="#StatsAPI.pvalue-Tuple{SurrogateTest}"><code>pvalue</code></a>. The tests requires as input a function <code>f</code> that given a timeseries (like <code>x</code>) it outputs a real number, and a method of how to generate surrogates. <code>f</code> is the function that computes the discriminatory statistic.</p><p>Once called with <a href="#StatsAPI.pvalue-Tuple{SurrogateTest}"><code>pvalue</code></a>, the <code>test</code> stores the real value <code>rval</code> and surrogate values <code>vals</code> of the discriminatory statistic in the fields <code>rval, vals</code> respectively.</p><p><code>SurrogateTest</code> automates the process described in the documentation page <a href="man/whatisasurrogate/#Performing-surrogate-hypothesis-tests">Performing surrogate hypothesis tests</a>.</p><p><code>SurrogateTest</code> subtypes <code>HypothesisTest</code> and is part of the StatsAPI.jl interface.</p><p><strong>Keywords</strong></p><ul><li><code>rng = Random.default_rng()</code>: a random number generator.</li><li><code>n::Int = 10_000</code>: how many surrogates to generate and compute <code>f</code> on.</li><li><code>threaded = true</code>: Whether to parallelize looping over surrogate computations in <a href="#StatsAPI.pvalue-Tuple{SurrogateTest}"><code>pvalue</code></a> to the available threads (<code>Threads.nthreads()</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TimeseriesSurrogates.jl/blob/6a1cec87b0133b3e1351b81a74806bafe3a55fb5/src/core/surrogate_test.jl#L6-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsAPI.pvalue-Tuple{SurrogateTest}" href="#StatsAPI.pvalue-Tuple{SurrogateTest}"><code>StatsAPI.pvalue</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pvalue(test::SurrogateTest; tail = :left)</code></pre><p>Return the <a href="https://en.wikipedia.org/wiki/P-value">p-value</a> corresponding to the given <a href="#TimeseriesSurrogates.SurrogateTest"><code>SurrogateTest</code></a>, optionally specifying what kind of tail test to do (one of <code>:left, :right, :both</code>).</p><p>For <a href="#TimeseriesSurrogates.SurrogateTest"><code>SurrogateTest</code></a>, the p-value is simply the proportion of surrogate statistics that exceed (for <code>tail = :right</code>) or subseed (<code>tail = :left</code>) the discriminatory statistic computed from the input data.</p><p>The default value of <code>tail</code> assumes that the surrogate data are expected to have higher discriminatory statistic values. This is the case for statistics that quantify entropy. For statistics that quantify autocorrelation, use <code>tail = :right</code> instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TimeseriesSurrogates.jl/blob/6a1cec87b0133b3e1351b81a74806bafe3a55fb5/src/core/surrogate_test.jl#L89-L103">source</a></section></article><h2 id="Surrogate-methods"><a class="docs-heading-anchor" href="#Surrogate-methods">Surrogate methods</a><a id="Surrogate-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Surrogate-methods" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="TimeseriesSurrogates.Surrogate" href="#TimeseriesSurrogates.Surrogate"><code>TimeseriesSurrogates.Surrogate</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Supertype of all surrogate methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TimeseriesSurrogates.jl/blob/6a1cec87b0133b3e1351b81a74806bafe3a55fb5/src/core/api.jl#L3">source</a></section></article><ul><li><a href="#TimeseriesSurrogates.AAFT"><code>TimeseriesSurrogates.AAFT</code></a></li><li><a href="#TimeseriesSurrogates.BlockShuffle"><code>TimeseriesSurrogates.BlockShuffle</code></a></li><li><a href="#TimeseriesSurrogates.CircShift"><code>TimeseriesSurrogates.CircShift</code></a></li><li><a href="#TimeseriesSurrogates.CycleShuffle"><code>TimeseriesSurrogates.CycleShuffle</code></a></li><li><a href="#TimeseriesSurrogates.IAAFT"><code>TimeseriesSurrogates.IAAFT</code></a></li><li><a href="#TimeseriesSurrogates.PartialRandomization"><code>TimeseriesSurrogates.PartialRandomization</code></a></li><li><a href="#TimeseriesSurrogates.PartialRandomizationAAFT"><code>TimeseriesSurrogates.PartialRandomizationAAFT</code></a></li><li><a href="#TimeseriesSurrogates.PseudoPeriodic"><code>TimeseriesSurrogates.PseudoPeriodic</code></a></li><li><a href="#TimeseriesSurrogates.PseudoPeriodicTwin"><code>TimeseriesSurrogates.PseudoPeriodicTwin</code></a></li><li><a href="#TimeseriesSurrogates.RandomCascade"><code>TimeseriesSurrogates.RandomCascade</code></a></li><li><a href="#TimeseriesSurrogates.RandomFourier"><code>TimeseriesSurrogates.RandomFourier</code></a></li><li><a href="#TimeseriesSurrogates.RandomShuffle"><code>TimeseriesSurrogates.RandomShuffle</code></a></li><li><a href="#TimeseriesSurrogates.RelativePartialRandomization"><code>TimeseriesSurrogates.RelativePartialRandomization</code></a></li><li><a href="#TimeseriesSurrogates.RelativePartialRandomizationAAFT"><code>TimeseriesSurrogates.RelativePartialRandomizationAAFT</code></a></li><li><a href="#TimeseriesSurrogates.SpectralPartialRandomization"><code>TimeseriesSurrogates.SpectralPartialRandomization</code></a></li><li><a href="#TimeseriesSurrogates.SpectralPartialRandomizationAAFT"><code>TimeseriesSurrogates.SpectralPartialRandomizationAAFT</code></a></li><li><a href="#TimeseriesSurrogates.Surrogate"><code>TimeseriesSurrogates.Surrogate</code></a></li><li><a href="#TimeseriesSurrogates.SurrogateTest"><code>TimeseriesSurrogates.SurrogateTest</code></a></li><li><a href="#TimeseriesSurrogates.TAAFT"><code>TimeseriesSurrogates.TAAFT</code></a></li><li><a href="#TimeseriesSurrogates.TFTD"><code>TimeseriesSurrogates.TFTD</code></a></li><li><a href="#TimeseriesSurrogates.TFTDAAFT"><code>TimeseriesSurrogates.TFTDAAFT</code></a></li><li><a href="#TimeseriesSurrogates.TFTDIAAFT"><code>TimeseriesSurrogates.TFTDIAAFT</code></a></li><li><a href="#TimeseriesSurrogates.TFTDRandomFourier"><code>TimeseriesSurrogates.TFTDRandomFourier</code></a></li><li><a href="#TimeseriesSurrogates.TFTS"><code>TimeseriesSurrogates.TFTS</code></a></li><li><a href="#TimeseriesSurrogates.WLS"><code>TimeseriesSurrogates.WLS</code></a></li></ul><h3 id="Shuffle-based"><a class="docs-heading-anchor" href="#Shuffle-based">Shuffle-based</a><a id="Shuffle-based-1"></a><a class="docs-heading-anchor-permalink" href="#Shuffle-based" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="TimeseriesSurrogates.RandomShuffle" href="#TimeseriesSurrogates.RandomShuffle"><code>TimeseriesSurrogates.RandomShuffle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RandomShuffle() &lt;: Surrogate</code></pre><p>A random constrained surrogate, generated by shifting values around.</p><p>Random shuffle surrogates preserve the mean, variance and amplitude  distribution of the original signal. Properties not preserved are <em>any  temporal information</em>, such as the power spectrum and hence linear  correlations. </p><p>The null hypothesis this method can test for is whether the data  are uncorrelated noise, possibly measured via a nonlinear function. Specifically, random shuffle surrogate can test  the null hypothesis that the original signal is produced by independent and  identically distributed random variables[^Theiler1991, ^Lancaster2018]. </p><p><em>Beware: random shuffle surrogates do not cover the case of correlated noise</em><sup class="footnote-reference"><a id="citeref-Lancaster2018" href="#footnote-Lancaster2018">[Lancaster2018]</a></sup>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TimeseriesSurrogates.jl/blob/6a1cec87b0133b3e1351b81a74806bafe3a55fb5/src/methods/randomshuffle.jl#L4-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeseriesSurrogates.BlockShuffle" href="#TimeseriesSurrogates.BlockShuffle"><code>TimeseriesSurrogates.BlockShuffle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BlockShuffle(n::Int; shift = false)</code></pre><p>A block shuffle surrogate constructed by dividing the time series into <code>n</code> blocks of roughly equal width at random indices (end blocks are wrapped around to the start of the time series).</p><p>If <code>shift</code> is <code>true</code>, then the input signal is circularly shifted by a  random number of steps prior to picking blocks.</p><p>Block shuffle surrogates roughly preserve short-range temporal properties in the time series (e.g. correlations at lags less than the block length), but break any long-term dynamical information (e.g. correlations beyond the block length).</p><p>Hence, these surrogates can be used to test any null hypothesis aimed at comparing short-range dynamical properties versus long-range dynamical properties of the signal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TimeseriesSurrogates.jl/blob/6a1cec87b0133b3e1351b81a74806bafe3a55fb5/src/methods/large_shuffle.jl#L17-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeseriesSurrogates.CycleShuffle" href="#TimeseriesSurrogates.CycleShuffle"><code>TimeseriesSurrogates.CycleShuffle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CycleShuffle(n::Int = 7, σ = 0.5)</code></pre><p>Cycle shuffled surrogates<sup class="footnote-reference"><a id="citeref-Theiler1994" href="#footnote-Theiler1994">[Theiler1994]</a></sup> that identify successive local peaks in the data and shuffle the cycles in-between the peaks. Similar to <a href="#TimeseriesSurrogates.BlockShuffle"><code>BlockShuffle</code></a>, but here the &quot;blocks&quot; are defined as follows:</p><ol><li>The timeseries is smoothened via convolution with a Gaussian (<code>DSP.gaussian(n, σ)</code>).</li><li>Local maxima of the smoothened signal define the peaks, and thus the blocks in between them.</li><li>The first and last index of timeseries can never be peaks and thus signals that should have peaks very close to start or end of the timeseries may not perform well. In addition, points before the first or after the last peak are never shuffled.</li><li>The defined blocks are randomly shuffled as in <a href="#TimeseriesSurrogates.BlockShuffle"><code>BlockShuffle</code></a>.</li></ol><p>CSS are used to test the null hypothesis that the signal is generated by a periodic oscillator with no dynamical correlation between cycles, i.e. the evolution of cycles is not deterministic.</p><p>See also <a href="#TimeseriesSurrogates.PseudoPeriodic"><code>PseudoPeriodic</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TimeseriesSurrogates.jl/blob/6a1cec87b0133b3e1351b81a74806bafe3a55fb5/src/methods/large_shuffle.jl#L132-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeseriesSurrogates.CircShift" href="#TimeseriesSurrogates.CircShift"><code>TimeseriesSurrogates.CircShift</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CircShift(n)</code></pre><p>Surrogates that are circularly shifted versions of the original timeseries.</p><p><code>n</code> can be an integer (the surrogate is the original time series shifted  by <code>n</code> indices), or any vector of integers, which which means that each  surrogate is shifted by an integer selected randomly among the entries in <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TimeseriesSurrogates.jl/blob/6a1cec87b0133b3e1351b81a74806bafe3a55fb5/src/methods/large_shuffle.jl#L191-L198">source</a></section></article><h3 id="Fourier-based"><a class="docs-heading-anchor" href="#Fourier-based">Fourier-based</a><a id="Fourier-based-1"></a><a class="docs-heading-anchor-permalink" href="#Fourier-based" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="TimeseriesSurrogates.RandomFourier" href="#TimeseriesSurrogates.RandomFourier"><code>TimeseriesSurrogates.RandomFourier</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RandomFourier(phases = true)</code></pre><p>A surrogate that randomizes the Fourier components of the signal in some manner. If <code>phases==true</code>, the phases are randomized, otherwise the amplitudes are randomized. <code>FT</code> is an alias for <code>RandomFourier</code>.</p><p>Random Fourier phase surrogates<sup class="footnote-reference"><a id="citeref-Theiler1991" href="#footnote-Theiler1991">[Theiler1991]</a></sup> preserve the autocorrelation function, or power spectrum, of the original signal. Random Fourier amplitude surrogates preserve the mean and autocorrelation function but do not preserve the variance of the original. Random amplitude surrogates are not common in the literature, but are provided for convenience.</p><p>Random phase surrogates can be used to test the null hypothesis that the original signal was produced by a linear Gaussian process <sup class="footnote-reference"><a id="citeref-Theiler1991" href="#footnote-Theiler1991">[Theiler1991]</a></sup>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TimeseriesSurrogates.jl/blob/6a1cec87b0133b3e1351b81a74806bafe3a55fb5/src/methods/randomfourier.jl#L7-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeseriesSurrogates.TFTDRandomFourier" href="#TimeseriesSurrogates.TFTDRandomFourier"><code>TimeseriesSurrogates.TFTDRandomFourier</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TFTD(phases::Bool = true, fϵ = 0.05)</code></pre><p>The <code>TFTDRandomFourier</code> (or just <code>TFTD</code> for short) surrogate was proposed by Lucio et al. (2012)<sup class="footnote-reference"><a id="citeref-Lucio2012" href="#footnote-Lucio2012">[Lucio2012]</a></sup> as a combination of truncated Fourier surrogates<sup class="footnote-reference"><a id="citeref-Nakamura2006" href="#footnote-Nakamura2006">[Nakamura2006]</a></sup> (<a href="#TimeseriesSurrogates.TFTS"><code>TFTS</code></a>) and detrend-retrend surrogates.</p><p>The <code>TFTD</code> part of the name comes from the fact that it uses a combination of truncated Fourier transforms (TFT) and de-trending and re-trending (D) the time series before and after surrogate generation. Hence, it can be used to generate surrogates also from (strongly) nonstationary time series.</p><p><strong>Implementation details</strong></p><p>Here, a best-fit linear trend is removed/added from the signal prior to and after generating the random Fourier signal. In principle, any trend can be removed, but so far, we only provide the linear option.</p><p>See also: <a href="#TimeseriesSurrogates.TFTDAAFT"><code>TFTDAAFT</code></a>, <a href="#TimeseriesSurrogates.TFTDIAAFT"><code>TFTDIAAFT</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TimeseriesSurrogates.jl/blob/6a1cec87b0133b3e1351b81a74806bafe3a55fb5/src/methods/trend_based.jl#L17-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeseriesSurrogates.PartialRandomization" href="#TimeseriesSurrogates.PartialRandomization"><code>TimeseriesSurrogates.PartialRandomization</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PartialRandomization(α = 0.5)</code></pre><p><code>PartialRandomization</code> surrogates<sup class="footnote-reference"><a id="citeref-Ortega1998" href="#footnote-Ortega1998">[Ortega1998]</a></sup> are similar to <a href="#TimeseriesSurrogates.RandomFourier"><code>RandomFourier</code></a> phase surrogates, but during the phase randomization step, instead of drawing phases from <code>[0, 2π]</code>, phases are drawn from <code>[0, 2π]*α</code>, where <code>α ∈ [0, 1]</code>. The authors refers to <code>α</code> as the &quot;degree&quot; of phase randomization, where <code>α = 0</code> means <code>0 %</code> randomization and <code>α = 1</code> means <code>100 %</code> randomization.</p><p>See <a href="#TimeseriesSurrogates.RelativePartialRandomization"><code>RelativePartialRandomization</code></a> and <a href="#TimeseriesSurrogates.SpectralPartialRandomization"><code>SpectralPartialRandomization</code></a> for alternative partial-randomization algorithms</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TimeseriesSurrogates.jl/blob/6a1cec87b0133b3e1351b81a74806bafe3a55fb5/src/methods/partial_randomization.jl#L3-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeseriesSurrogates.PartialRandomizationAAFT" href="#TimeseriesSurrogates.PartialRandomizationAAFT"><code>TimeseriesSurrogates.PartialRandomizationAAFT</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PartialRandomizationAAFT(α = 0.5)</code></pre><p><code>PartialRandomizationAAFF</code> surrogates are similar to <a href="#TimeseriesSurrogates.PartialRandomization"><code>PartialRandomization</code></a> surrogates<sup class="footnote-reference"><a id="citeref-Ortega1998" href="#footnote-Ortega1998">[Ortega1998]</a></sup>, but adds a rescaling step, so that the surrogate has the same values as the original time series (analogous to the rescaling done for <a href="#TimeseriesSurrogates.AAFT"><code>AAFT</code></a> surrogates). Partial randomization surrogates have, to the package authors&#39; knowledge, not been published in scientific literature.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TimeseriesSurrogates.jl/blob/6a1cec87b0133b3e1351b81a74806bafe3a55fb5/src/methods/partial_randomization.jl#L54-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeseriesSurrogates.RelativePartialRandomization" href="#TimeseriesSurrogates.RelativePartialRandomization"><code>TimeseriesSurrogates.RelativePartialRandomization</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RelativePartialRandomization(α = 0.5)</code></pre><p><code>RelativePartialRandomization</code> surrogates are similar to <a href="#TimeseriesSurrogates.PartialRandomization"><code>PartialRandomization</code></a> phase surrogates, but instead of drawing phases uniformly from <code>[0, 2π]</code>, phases are drawn from <code>ϕ + [0, 2π]*α</code>, where <code>α ∈ [0, 1]</code> and <code>ϕ</code> is the original Fourier phase.</p><p>See the documentation for a detailed comparison between partial randomization algorithms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TimeseriesSurrogates.jl/blob/6a1cec87b0133b3e1351b81a74806bafe3a55fb5/src/methods/relative_partial_randomization.jl#L3-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeseriesSurrogates.RelativePartialRandomizationAAFT" href="#TimeseriesSurrogates.RelativePartialRandomizationAAFT"><code>TimeseriesSurrogates.RelativePartialRandomizationAAFT</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RelativePartialRandomizationAAFT(α = 0.5)</code></pre><p><code>RelativePartialRandomizationAAFT</code> surrogates are similar to <a href="#TimeseriesSurrogates.RelativePartialRandomization"><code>RelativePartialRandomization</code></a> surrogates, but add a rescaling step, so that the surrogate has the same values as the original time series (analogous to the rescaling done for <a href="#TimeseriesSurrogates.AAFT"><code>AAFT</code></a> surrogates).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TimeseriesSurrogates.jl/blob/6a1cec87b0133b3e1351b81a74806bafe3a55fb5/src/methods/relative_partial_randomization.jl#L51-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeseriesSurrogates.SpectralPartialRandomization" href="#TimeseriesSurrogates.SpectralPartialRandomization"><code>TimeseriesSurrogates.SpectralPartialRandomization</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SpectralSpectralPartialRandomization(α = 0.5)</code></pre><p><code>SpectralPartialRandomization</code> surrogates are similar to <a href="#TimeseriesSurrogates.PartialRandomization"><code>PartialRandomization</code></a> phase surrogates, but instead of drawing phases uniformly from <code>[0, 2π]</code>, phases of the highest frequency components responsible for a proportion <code>α</code> of power are replaced by random phases drawn from <code>[0, 2π]</code></p><p>See the documentation for a detailed comparison between partial randomization algorithms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TimeseriesSurrogates.jl/blob/6a1cec87b0133b3e1351b81a74806bafe3a55fb5/src/methods/spectral_partial_randomization.jl#L3-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeseriesSurrogates.SpectralPartialRandomizationAAFT" href="#TimeseriesSurrogates.SpectralPartialRandomizationAAFT"><code>TimeseriesSurrogates.SpectralPartialRandomizationAAFT</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SpectralPartialRandomizationAAFT(α = 0.5)</code></pre><p><code>SpectralPartialRandomizationAAFT</code> surrogates are similar to <a href="#TimeseriesSurrogates.PartialRandomization"><code>PartialRandomization</code></a> surrogates, but add a rescaling step, so that the surrogate has the same values as the original time series (analogous to the rescaling done for <a href="#TimeseriesSurrogates.AAFT"><code>AAFT</code></a> surrogates).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TimeseriesSurrogates.jl/blob/6a1cec87b0133b3e1351b81a74806bafe3a55fb5/src/methods/spectral_partial_randomization.jl#L58-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeseriesSurrogates.AAFT" href="#TimeseriesSurrogates.AAFT"><code>TimeseriesSurrogates.AAFT</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AAFT()</code></pre><p>An amplitude-adjusted-fourier-transform (AAFT) surrogate<sup class="footnote-reference"><a id="citeref-Theiler1991" href="#footnote-Theiler1991">[Theiler1991]</a></sup>.</p><p>AAFT surrogates have the same linear correlation, or periodogram, and also preserves the amplitude distribution of the original data.</p><p>AAFT surrogates can be used to test the null hypothesis that the data come from a monotonic nonlinear transformation of a linear Gaussian process (also called integrated white noise)<sup class="footnote-reference"><a id="citeref-Theiler1991" href="#footnote-Theiler1991">[Theiler1991]</a></sup>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TimeseriesSurrogates.jl/blob/6a1cec87b0133b3e1351b81a74806bafe3a55fb5/src/methods/aaft.jl#L3-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeseriesSurrogates.TAAFT" href="#TimeseriesSurrogates.TAAFT"><code>TimeseriesSurrogates.TAAFT</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TAAFT(fϵ)</code></pre><p>An truncated version of the amplitude-adjusted-fourier-transform surrogate<sup class="footnote-reference"><a id="citeref-Theiler1991" href="#footnote-Theiler1991">[Theiler1991]</a></sup><sup class="footnote-reference"><a id="citeref-Nakamura2006" href="#footnote-Nakamura2006">[Nakamura2006]</a></sup>.</p><p>The truncation parameter and phase randomization procedure is identical to <a href="#TimeseriesSurrogates.TFTS"><code>TFTS</code></a>, but here an additional step of rescaling back to the original data is performed. This preserves the amplitude distribution of the original data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TimeseriesSurrogates.jl/blob/6a1cec87b0133b3e1351b81a74806bafe3a55fb5/src/methods/truncated_fourier.jl#L111-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeseriesSurrogates.IAAFT" href="#TimeseriesSurrogates.IAAFT"><code>TimeseriesSurrogates.IAAFT</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IAAFT(M = 100, tol = 1e-6, W = 75)</code></pre><p>An iteratively adjusted amplitude-adjusted-fourier-transform surrogate<sup class="footnote-reference"><a id="citeref-SchreiberSchmitz1996" href="#footnote-SchreiberSchmitz1996">[SchreiberSchmitz1996]</a></sup>.</p><p>IAAFT surrogates have the same linear correlation, or periodogram, and also preserves the amplitude distribution of the original data, but are improved relative to AAFT through iterative adjustment (which runs for a maximum of <code>M</code> steps). During the iterative adjustment, the periodograms of the original signal and the surrogate are coarse-grained and the powers are averaged over <code>W</code> equal-width frequency bins. The iteration procedure ends when the relative deviation between the periodograms is less than <code>tol</code> (or when <code>M</code> is reached).</p><p>IAAFT, just as AAFT, can be used to test the null hypothesis that the data come from a monotonic nonlinear transformation of a linear Gaussian process.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TimeseriesSurrogates.jl/blob/6a1cec87b0133b3e1351b81a74806bafe3a55fb5/src/methods/iaaft.jl#L8-L25">source</a></section></article><h3 id="Non-stationary"><a class="docs-heading-anchor" href="#Non-stationary">Non-stationary</a><a id="Non-stationary-1"></a><a class="docs-heading-anchor-permalink" href="#Non-stationary" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="TimeseriesSurrogates.TFTS" href="#TimeseriesSurrogates.TFTS"><code>TimeseriesSurrogates.TFTS</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TFTS(fϵ::Real)</code></pre><p>A truncated Fourier transform surrogate<sup class="footnote-reference"><a id="citeref-Nakamura2006" href="#footnote-Nakamura2006">[Nakamura2006]</a></sup> (TFTS).</p><p>TFTS surrogates are generated by leaving some frequencies untouched when performing the phase shuffling step (as opposed to randomizing all frequencies, like for <a href="#TimeseriesSurrogates.RandomFourier"><code>RandomFourier</code></a> surrogates).</p><p>These surrogates were designed to deal with data with irregular fluctuations superimposed over long term trends (by preserving low frequencies)<sup class="footnote-reference"><a id="citeref-Nakamura2006" href="#footnote-Nakamura2006">[Nakamura2006]</a></sup>. Hence, TFTS surrogates can be used to test the null hypothesis that the signal is a stationary linear system generated the irregular fluctuations part of the signal<sup class="footnote-reference"><a id="citeref-Nakamura2006" href="#footnote-Nakamura2006">[Nakamura2006]</a></sup>.</p><p><strong>Controlling the truncation of the spectrum</strong></p><p>The truncation parameter <code>fϵ ∈ [-1, 0) ∪ (0, 1]</code> controls which parts of the spectrum are preserved.</p><ul><li>If <code>fϵ &gt; 0</code>, then <code>fϵ</code> indicates the ratio of high frequency domain to the entire frequency domain.   For example, <code>fϵ = 0.5</code> preserves 50% of the frequency domain (randomizing the higher   frequencies, leaving low frequencies intact).</li><li>If <code>fϵ &lt; 0</code>, then <code>fϵ</code> indicates ratio of low frequency domain to the entire frequency domain.   For example, <code>fϵ = -0.2</code> preserves 20% of the frequency domain (leaving higher frequencies intact,   randomizing the lower frequencies).</li><li>If <code>fϵ ± 1</code>, then all frequencies are randomized. The method is then equivalent to   <a href="#TimeseriesSurrogates.RandomFourier"><code>RandomFourier</code></a>.</li></ul><p>The appropriate value of <code>fϵ</code> strongly depends on the data and time series length, and must be manually determined<sup class="footnote-reference"><a id="citeref-Nakamura2006" href="#footnote-Nakamura2006">[Nakamura2006]</a></sup>, for example by comparing periodograms for the time series and the surrogates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TimeseriesSurrogates.jl/blob/6a1cec87b0133b3e1351b81a74806bafe3a55fb5/src/methods/truncated_fourier.jl#L4-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeseriesSurrogates.TFTD" href="#TimeseriesSurrogates.TFTD"><code>TimeseriesSurrogates.TFTD</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TFTD(phases::Bool = true, fϵ = 0.05)</code></pre><p>The <code>TFTDRandomFourier</code> (or just <code>TFTD</code> for short) surrogate was proposed by Lucio et al. (2012)<sup class="footnote-reference"><a id="citeref-Lucio2012" href="#footnote-Lucio2012">[Lucio2012]</a></sup> as a combination of truncated Fourier surrogates<sup class="footnote-reference"><a id="citeref-Nakamura2006" href="#footnote-Nakamura2006">[Nakamura2006]</a></sup> (<a href="#TimeseriesSurrogates.TFTS"><code>TFTS</code></a>) and detrend-retrend surrogates.</p><p>The <code>TFTD</code> part of the name comes from the fact that it uses a combination of truncated Fourier transforms (TFT) and de-trending and re-trending (D) the time series before and after surrogate generation. Hence, it can be used to generate surrogates also from (strongly) nonstationary time series.</p><p><strong>Implementation details</strong></p><p>Here, a best-fit linear trend is removed/added from the signal prior to and after generating the random Fourier signal. In principle, any trend can be removed, but so far, we only provide the linear option.</p><p>See also: <a href="#TimeseriesSurrogates.TFTDAAFT"><code>TFTDAAFT</code></a>, <a href="#TimeseriesSurrogates.TFTDIAAFT"><code>TFTDIAAFT</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TimeseriesSurrogates.jl/blob/6a1cec87b0133b3e1351b81a74806bafe3a55fb5/src/methods/trend_based.jl#L17-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeseriesSurrogates.TFTDAAFT" href="#TimeseriesSurrogates.TFTDAAFT"><code>TimeseriesSurrogates.TFTDAAFT</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TFTDAAFT(fϵ = 0.05)</code></pre><p><a href="#TimeseriesSurrogates.TFTDAAFT"><code>TFTDAAFT</code></a><sup class="footnote-reference"><a id="citeref-Lucio2012" href="#footnote-Lucio2012">[Lucio2012]</a></sup> are similar to <a href="#TimeseriesSurrogates.TFTD"><code>TFTD</code></a> surrogates, but also re-scales back to the original values of the time series. <code>fϵ ∈ (0, 1]</code> is the fraction of the powerspectrum corresponding to the lowermost frequencies to be preserved.</p><p>See also: <a href="#TimeseriesSurrogates.TFTD"><code>TFTD</code></a>, <a href="#TimeseriesSurrogates.TFTDIAAFT"><code>TFTDIAAFT</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TimeseriesSurrogates.jl/blob/6a1cec87b0133b3e1351b81a74806bafe3a55fb5/src/methods/trend_based.jl#L125-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeseriesSurrogates.TFTDIAAFT" href="#TimeseriesSurrogates.TFTDIAAFT"><code>TimeseriesSurrogates.TFTDIAAFT</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TFTDIAAFT(fϵ = 0.05; M::Int = 100, tol::Real = 1e-6, W::Int = 75)</code></pre><p><a href="#TimeseriesSurrogates.TFTDIAAFT"><code>TFTDIAAFT</code></a><sup class="footnote-reference"><a id="citeref-Lucio2012" href="#footnote-Lucio2012">[Lucio2012]</a></sup> are similar to <a href="#TimeseriesSurrogates.TFTDAAFT"><code>TFTDAAFT</code></a>, but adds an iterative procedure to better match the periodograms of the surrogate and the original time series, analogously to how <a href="#TimeseriesSurrogates.IAAFT"><code>IAAFT</code></a> improves upon <a href="#TimeseriesSurrogates.AAFT"><code>AAFT</code></a>.</p><p><code>fϵ ∈ (0, 1]</code> is the fraction of the powerspectrum corresponding to the lowermost frequencies to be preserved. <code>M</code> is the maximum number of iterations. <code>tol</code> is the desired maximum relative tolerance between power spectra. <code>W</code> is the number of bins into which the periodograms are binned when comparing across iterations.</p><p>See also: <a href="#TimeseriesSurrogates.TFTD"><code>TFTD</code></a>, <a href="#TimeseriesSurrogates.TFTDAAFT"><code>TFTDAAFT</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TimeseriesSurrogates.jl/blob/6a1cec87b0133b3e1351b81a74806bafe3a55fb5/src/methods/trend_based.jl#L168-L183">source</a></section></article><h3 id="Pseudo-periodic"><a class="docs-heading-anchor" href="#Pseudo-periodic">Pseudo-periodic</a><a id="Pseudo-periodic-1"></a><a class="docs-heading-anchor-permalink" href="#Pseudo-periodic" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="TimeseriesSurrogates.PseudoPeriodic" href="#TimeseriesSurrogates.PseudoPeriodic"><code>TimeseriesSurrogates.PseudoPeriodic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PseudoPeriodic(d, τ, ρ, shift = true)</code></pre><p>Create surrogates suitable for pseudo-periodic signals. They retain the periodic structure of the signal, while inter-cycle dynamics that are either deterministic or correlated noise are destroyed (for appropriate <code>ρ</code> choice). Therefore these surrogates are suitable to test the null hypothesis that the signal is a periodic orbit with uncorrelated noise<sup class="footnote-reference"><a id="citeref-Small2001" href="#footnote-Small2001">[Small2001]</a></sup>.</p><p>Arguments <code>d, τ, ρ</code> are as in the paper, the embedding dimension, delay time and noise radius. The method works by performing a delay coordinates embedding from DelayEmbeddings.jl (see that docs for choosing appropriate <code>d, τ</code>). For <code>ρ</code>, we have implemented the method proposed in the paper in the function <a href="#TimeseriesSurrogates.noiseradius"><code>noiseradius</code></a>.</p><p>The argument <code>shift</code> is not discussed in the paper. If <code>shift=false</code> we adjust the algorithm so that there is little phase shift between the periodic component of the original and surrogate data.</p><p>See also <a href="#TimeseriesSurrogates.CycleShuffle"><code>CycleShuffle</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TimeseriesSurrogates.jl/blob/6a1cec87b0133b3e1351b81a74806bafe3a55fb5/src/methods/pseudoperiodic.jl#L4-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeseriesSurrogates.PseudoPeriodicTwin" href="#TimeseriesSurrogates.PseudoPeriodicTwin"><code>TimeseriesSurrogates.PseudoPeriodicTwin</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PseudoPeriodicTwin(d::Int, τ::Int, δ = 0.2, ρ = 0.1, metric = Euclidean())
PseudoPeriodicTwin(δ = 0.2, ρ = 0.1, metric = Euclidean())</code></pre><p>A pseudoperiodic twin surrogate<sup class="footnote-reference"><a id="citeref-Miralles2015" href="#footnote-Miralles2015">[Miralles2015]</a></sup>, which is a fusion of the twin surrogate<sup class="footnote-reference"><a id="citeref-Thiel2006" href="#footnote-Thiel2006">[Thiel2006]</a></sup> and the pseudo-periodic surrogate<sup class="footnote-reference"><a id="citeref-Small2001" href="#footnote-Small2001">[Small2001]</a></sup>.</p><p><strong>Input parameters</strong></p><p>A delay reconstruction of the input timeseries is constructed using embedding dimension <code>d</code> and embedding delay <code>τ</code>. The threshold <code>δ ∈ (0, 1]</code> determines which points are &quot;close&quot; (neighbors) or not, and is expressed as a fraction of the attractor diameter, as determined by the input data. The authors of the original twin surrogate paper recommend <code>0.05 ≤ δ ≤ 0.2</code><sup class="footnote-reference"><a id="citeref-Thiel2006" href="#footnote-Thiel2006">[Thiel2006]</a></sup>.</p><p>If you have pre-embedded your timeseries, and timeseries is already a <code>::StateSpaceSet</code>, use the three-argument constructor (so that no delay reconstruction is performed). If you want a surrogate for a scalar-valued timeseries, use the five-argument constructor to also provide the embedding delay <code>τ</code> and embedding dimension <code>d</code>.</p><p><strong>Null hypothesis</strong></p><p>Pseudo-periodic twin surrogates generate signals similar to the original data if the original signal is (quasi-)periodic. If the original signal is not (quasi-)periodic, then these surrogates will have different recurrence plots than the original signal, but preserve the overall shape of the attractor. Thus, <code>PseudoPeriodicTwin</code> surrogates can be used to test null hypothesis that the observed timeseries (or orbit) is consistent with a quasi-periodic orbit<sup class="footnote-reference"><a id="citeref-Miralles2015" href="#footnote-Miralles2015">[Miralles2015]</a></sup>.</p><p><strong>Returns</strong></p><p>A <code>d</code>-dimensional surrogate orbit (a <code>StateSpaceSet</code>) is returned. Sample the first column of this dataset if a scalar-valued surrogate is desired.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TimeseriesSurrogates.jl/blob/6a1cec87b0133b3e1351b81a74806bafe3a55fb5/src/methods/pseudoperiodic_twin.jl#L8-L46">source</a></section></article><h3 id="Wavelet-based"><a class="docs-heading-anchor" href="#Wavelet-based">Wavelet-based</a><a id="Wavelet-based-1"></a><a class="docs-heading-anchor-permalink" href="#Wavelet-based" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="TimeseriesSurrogates.WLS" href="#TimeseriesSurrogates.WLS"><code>TimeseriesSurrogates.WLS</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WLS(shufflemethod::Surrogate = IAAFT();
    f::Union{Nothing, Function} = Statistics.cor,
    rescale::Bool = true,
    wt::Wavelets.WT.OrthoWaveletClass = Wavelets.WT.Daubechies{16}())</code></pre><p>A wavelet surrogate generated by the following procedure:</p><ol><li>Compute the wavelet transform of the signal. This results in a set of   detail coefficients over a set of dyadic scales. As in Keylock (2006),   we here use the maximal overlap discrete wavelet transform, or MODWT,  so that the number of coefficients at each scale are the same.</li><li>Shuffle the detail coefficients at each dyadic scale using the   provided <code>shufflemethod</code>. See &quot;Shuffling methods&quot; below for alternatives.</li><li>Apply the inverse wavelet transform to the shuffled detail coefficients   to obtain a surrogate time series.</li></ol><p><strong>Shuffling methods</strong></p><p>You may choose to use any surrogate from this package to perform the  randomization of the detail coefficients at each dyadic scale.</p><p>The following methods have been discussed in the literature (more may exist): </p><ul><li>Random permutations of wavelet coefficients within each scale (Breakspear et al., 2003). To get this behaviour, use <code>WLS(x, RandomShuffle(), rescale = false, f = nothing)</code>.</li><li>Cyclic rotation of wavelet coefficients within each scale (Breakspear et al., 2003).  To get this behaviour, use <code>WLS(x, Circshift(1:length(x)), rescale = false, f = nothing)</code>.</li><li>Block resampling of wavelet coefficients within each scale (Breakspear et al., 2003). To get this behaviour, use <code>WLS(x, BlockShuffle(nblocks, randomize = true), rescale = false, f = nothing)</code>.</li><li>IAAFT resampling of wavelet coefficients within each scale (Keylock, 2006). To get this behaviour, use <code>WLS(x, IAAFT(), rescale = true, f = Statistics.cor)</code>.   This method preserves the local mean and variance structure of the signal, but    randomises nonlinear properties of the signal (i.e. Hurst exponents)<sup class="footnote-reference"><a id="citeref-Keylock2006" href="#footnote-Keylock2006">[Keylock2006]</a></sup>.    These surrogates can therefore be used to test for changes in nonlinear properties    of the original signal. In contrast to IAAFT surrogates, the IAAFT-wavelet surrogates    also preserves nonstationarity. Using other <code>shufflemethod</code>s does not necessarily   preserve nonstationarity. To deal with nonstationary signals, Keylock (2006) recommends    using a wavelet with a high number of vanishing moments. Thus, our default is to   use a Daubechies wavelet with 16 vanishing moments. <em>Note: The iterative procedure after    the rank ordering step (step [v] in <sup class="footnote-reference"><a id="citeref-Keylock2006" href="#footnote-Keylock2006">[Keylock2006]</a></sup>) is not performed in    this implementation.</em></li></ul><p>The default method and parameters replicate the behaviour of Keylock (2006)&#39;s IAAFT  wavelet surrogates.</p><p><strong>Error minimization</strong></p><p>For the <a href="#TimeseriesSurrogates.IAAFT"><code>IAAFT</code></a> approach introduced in Keylock (2006), detail coefficients  at each level are circularly rotated to minimize an error function. The methods  introduced in Breakspear et al. (2003) do not apply this error minimization.</p><p>In our implementation, you can turn this option on/off using the <code>f</code> parameter of  the <code>WLS</code> constructor. If <code>f = nothing</code> turns off error minization. If <code>f</code> is set  to a two-argument function that computes some statistic, for example  <code>f = Statistics.cor</code>, then detail coefficients at each scale are circularly  rotated until that function is maximized (and hence the &quot;error&quot; minimized).  If you want to <em>minimize</em> some error function, then instead provide an appropriate  transform of your function. For example, if using the root mean squared deviation, define <code>rmsd_inv(x, y) = 1 - StatsBase.rmsd(x, y)</code> and set <code>f = rmsd_inv</code>.</p><p><strong>Rescaling</strong></p><p>If <code>rescale == true</code>, then surrogate values are mapped onto the  values of the original time series, as in the <a href="#TimeseriesSurrogates.AAFT"><code>AAFT</code></a> algorithm. If <code>rescale == false</code>, surrogate values are not constrained to the  original time series values. If <a href="#TimeseriesSurrogates.AAFT"><code>AAFT</code></a> or <a href="#TimeseriesSurrogates.IAAFT"><code>IAAFT</code></a> shuffling  is used, <code>rescale</code> should be set to <code>true</code>. For other methods, it does not  necessarily need to be.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TimeseriesSurrogates.jl/blob/6a1cec87b0133b3e1351b81a74806bafe3a55fb5/src/methods/wavelet_based.jl#L4-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeseriesSurrogates.RandomCascade" href="#TimeseriesSurrogates.RandomCascade"><code>TimeseriesSurrogates.RandomCascade</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RandomCascade(paddingmode::String = &quot;zeros&quot;)</code></pre><p>A random cascade multifractal wavelet surrogate (Paluš, 2008)<sup class="footnote-reference"><a id="citeref-Paluš2008" href="#footnote-Paluš2008">[Paluš2008]</a></sup>.</p><p>If the input signal length is not a power of 2, the signal must be  padded before the surrogate is constructed. <code>paddingmode</code> determines  how the signal is padded. Currently supported padding modes: <code>&quot;zeros&quot;</code>. The final surrogate (constructed from the padded signal) is subset to match the length of the original signal.</p><p>Random cascade surrogate preserve multifractal properties of the input  time series, that is, interactions among dyadic scales and nonlinear  dependencies<sup class="footnote-reference"><a id="citeref-Paluš2008" href="#footnote-Paluš2008">[Paluš2008]</a></sup>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TimeseriesSurrogates.jl/blob/6a1cec87b0133b3e1351b81a74806bafe3a55fb5/src/methods/wavelet_based.jl#L265-L281">source</a></section></article><h3 id="Other"><a class="docs-heading-anchor" href="#Other">Other</a><a id="Other-1"></a><a class="docs-heading-anchor-permalink" href="#Other" title="Permalink"></a></h3><pre><code class="language- hljs">AutoRegressive
ShuffleDimensions
IrregularLombScargle</code></pre><h3 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="TimeseriesSurrogates.noiseradius" href="#TimeseriesSurrogates.noiseradius"><code>TimeseriesSurrogates.noiseradius</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">noiseradius(x::AbstractVector, d::Int, τ, ρs, n = 1) → ρ</code></pre><p>Use the proposed* algorithm of<sup class="footnote-reference"><a id="citeref-Small2001" href="#footnote-Small2001">[Small2001]</a></sup> to estimate optimal <code>ρ</code> value for <a href="#TimeseriesSurrogates.PseudoPeriodic"><code>PseudoPeriodic</code></a> surrogates, where <code>ρs</code> is a vector of possible <code>ρ</code> values. *The paper is ambiguous about exactly what to calculate. Here we count how many times we have pairs of length-2 that are identical in <code>x</code> and its surrogate, but <strong>are not</strong> also part of pairs of length-3.</p><p>This function directly returns the arg-maximum of the evaluated distribution of these counts versus <code>ρ</code>, use <code>TimeseriesSurrogates._noiseradius</code> with same arguments to get the actual distribution. <code>n</code> means to repeat τhe evaluation <code>n</code> times, which increases accuracy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/TimeseriesSurrogates.jl/blob/6a1cec87b0133b3e1351b81a74806bafe3a55fb5/src/methods/pseudoperiodic.jl#L68-L82">source</a></section></article><h2 id="Visualization"><a class="docs-heading-anchor" href="#Visualization">Visualization</a><a id="Visualization-1"></a><a class="docs-heading-anchor-permalink" href="#Visualization" title="Permalink"></a></h2><p>TimeseriesSurrogates.jl has defined a simple function <code>surroplot(x, s)</code>. This comes into scope when <code>using Makie</code> (you also need a plotting backend). This functionality requires you to be using Julia 1.9 or later versions.</p><p>Example:</p><pre><code class="language- hljs">using TimeseriesSurrogates
using CairoMakie
x = AR1() # create a realization of a random AR(1) process
fig = surroplot(x, AAFT())
save(&quot;surroplot.png&quot;, fig); # hide</code></pre><h2 id="Citing"><a class="docs-heading-anchor" href="#Citing">Citing</a><a id="Citing-1"></a><a class="docs-heading-anchor-permalink" href="#Citing" title="Permalink"></a></h2><p>Please use the following BiBTeX entry, or DOI, to cite TimeseriesSurrogates.jl:</p><p>DOI: https://doi.org/10.21105/joss.04414</p><p>BiBTeX:</p><pre><code class="language-latex hljs">@article{TimeseriesSurrogates.jl,
    doi = {10.21105/joss.04414},
    url = {https://doi.org/10.21105/joss.04414},
    year = {2022},
    publisher = {The Open Journal},
    volume = {7},
    number = {77},
    pages = {4414},
    author = {Kristian Agasøster Haaga and George Datseris},
    title = {TimeseriesSurrogates.jl: a Julia package for generating surrogate data},
    journal = {Journal of Open Source Software}
}</code></pre><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Theiler1991"><a class="tag is-link" href="#citeref-Theiler1991">Theiler1991</a>J. Theiler, S. Eubank, A. Longtin, B. Galdrikian, J. Farmer, Testing for nonlinearity in time series: The method of surrogate data, Physica D 58 (1–4) (1992) 77–94.</li><li class="footnote" id="footnote-Theiler1994"><a class="tag is-link" href="#citeref-Theiler1994">Theiler1994</a>J. Theiler, On the evidence for low-dimensional chaos in an epileptic electroencephalogram, <a href="https://doi.org/10.1016/0375-9601(94)00856-K">Phys. Lett. A 196</a></li><li class="footnote" id="footnote-Theiler1991"><a class="tag is-link" href="#citeref-Theiler1991">Theiler1991</a>J. Theiler, S. Eubank, A. Longtin, B. Galdrikian, J. Farmer, Testing for nonlinearity in time series: The method of surrogate data, Physica D 58 (1–4) (1992) 77–94.</li><li class="footnote" id="footnote-Nakamura2006"><a class="tag is-link" href="#citeref-Nakamura2006">Nakamura2006</a>Nakamura, Tomomichi, Michael Small, and Yoshito Hirata. &quot;Testing for nonlinearity in irregular fluctuations with long-term trends.&quot; Physical Review E 74.2 (2006): 026205.</li><li class="footnote" id="footnote-Lucio2012"><a class="tag is-link" href="#citeref-Lucio2012">Lucio2012</a>Lucio, J. H., Valdés, R., &amp; Rodríguez, L. R. (2012). Improvements to surrogate data methods for nonstationary time series. Physical Review E, 85(5), 056202.</li><li class="footnote" id="footnote-Ortega1998"><a class="tag is-link" href="#citeref-Ortega1998">Ortega1998</a>Ortega, Guillermo J.; Louis, Enrique (1998). Smoothness Implies Determinism in Time Series: A Measure Based Approach. Physical Review Letters, 81(20), 4345–4348. doi:10.1103/PhysRevLett.81.4345</li><li class="footnote" id="footnote-Ortega1998"><a class="tag is-link" href="#citeref-Ortega1998">Ortega1998</a>Ortega, Guillermo J.; Louis, Enrique (1998). Smoothness Implies Determinism in Time Series: A Measure Based Approach. Physical Review Letters, 81(20), 4345–4348. doi:10.1103/PhysRevLett.81.4345</li><li class="footnote" id="footnote-Theiler1991"><a class="tag is-link" href="#citeref-Theiler1991">Theiler1991</a>J. Theiler, S. Eubank, A. Longtin, B. Galdrikian, J. Farmer, Testing for nonlinearity in time series: The method of surrogate data, Physica D 58 (1–4) (1992) 77–94.</li><li class="footnote" id="footnote-Theiler1991"><a class="tag is-link" href="#citeref-Theiler1991">Theiler1991</a>J. Theiler, S. Eubank, A. Longtin, B. Galdrikian, J. Farmer, Testing for nonlinearity in time series: The method of surrogate data, Physica D 58 (1–4) (1992) 77–94.</li><li class="footnote" id="footnote-Nakamura2006"><a class="tag is-link" href="#citeref-Nakamura2006">Nakamura2006</a>Nakamura, Tomomichi, Michael Small, and Yoshito Hirata. &quot;Testing for nonlinearity in irregular fluctuations with long-term trends.&quot; Physical Review E 74.2 (2006): 026205.</li><li class="footnote" id="footnote-SchreiberSchmitz1996"><a class="tag is-link" href="#citeref-SchreiberSchmitz1996">SchreiberSchmitz1996</a>T. Schreiber; A. Schmitz (1996). &quot;Improved Surrogate Data for Nonlinearity Tests&quot;. <a href="https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.77.635">Phys. Rev. Lett. 77 (4)</a></li><li class="footnote" id="footnote-Nakamura2006"><a class="tag is-link" href="#citeref-Nakamura2006">Nakamura2006</a>Nakamura, Tomomichi, Michael Small, and Yoshito Hirata. &quot;Testing for nonlinearity in irregular fluctuations with long-term trends.&quot; Physical Review E 74.2 (2006): 026205.</li><li class="footnote" id="footnote-Nakamura2006"><a class="tag is-link" href="#citeref-Nakamura2006">Nakamura2006</a>Nakamura, Tomomichi, Michael Small, and Yoshito Hirata. &quot;Testing for nonlinearity in irregular fluctuations with long-term trends.&quot; Physical Review E 74.2 (2006): 026205.</li><li class="footnote" id="footnote-Lucio2012"><a class="tag is-link" href="#citeref-Lucio2012">Lucio2012</a>Lucio, J. H., Valdés, R., &amp; Rodríguez, L. R. (2012). Improvements to surrogate data methods for nonstationary time series. Physical Review E, 85(5), 056202.</li><li class="footnote" id="footnote-Lucio2012"><a class="tag is-link" href="#citeref-Lucio2012">Lucio2012</a>Lucio, J. H., Valdés, R., &amp; Rodríguez, L. R. (2012). Improvements to surrogate data methods for nonstationary time series. Physical Review E, 85(5), 056202.</li><li class="footnote" id="footnote-Lucio2012"><a class="tag is-link" href="#citeref-Lucio2012">Lucio2012</a>Lucio, J. H., Valdés, R., &amp; Rodríguez, L. R. (2012). Improvements to surrogate data methods for nonstationary time series. Physical Review E, 85(5), 056202.</li><li class="footnote" id="footnote-Small2001"><a class="tag is-link" href="#citeref-Small2001">Small2001</a>Small et al., Surrogate test for pseudoperiodic time series data, <a href="https://doi.org/10.1103/PhysRevLett.87.188101">Physical Review Letters, 87(18)</a></li><li class="footnote" id="footnote-Small2001"><a class="tag is-link" href="#citeref-Small2001">Small2001</a>Small et al., Surrogate test for pseudoperiodic timeseries data, <a href="https://doi.org/10.1103/PhysRevLett.87.188101">Physical Review Letters, 87(18)</a></li><li class="footnote" id="footnote-Thiel2006"><a class="tag is-link" href="#citeref-Thiel2006">Thiel2006</a>Thiel, Marco, et al. &quot;Twin surrogates to test for complex synchronisation.&quot; EPL (Europhysics Letters) 75.4 (2006): 535.</li><li class="footnote" id="footnote-Miralles2015"><a class="tag is-link" href="#citeref-Miralles2015">Miralles2015</a>Miralles, R., et al. &quot;Characterization of the complexity in short oscillating timeseries: An application to seismic airgun detonations.&quot; The Journal of the Acoustical Society of America 138.3 (2015): 1595-1603.</li><li class="footnote" id="footnote-Breakspear2003"><a class="tag is-link" href="#citeref-Breakspear2003">Breakspear2003</a>Breakspear, M., Brammer, M., &amp; Robinson, P. A. (2003). Construction of multivariate surrogate sets from nonlinear data using the wavelet transform. Physica D: Nonlinear Phenomena, 182(1-2), 1-22.</li><li class="footnote" id="footnote-Keylock2006"><a class="tag is-link" href="#citeref-Keylock2006">Keylock2006</a>C.J. Keylock (2006). &quot;Constrained surrogate time series with preservation of the mean and variance structure&quot;. Phys. Rev. E. 73: 036707. doi:10.1103/PhysRevE.73.036707.</li><li class="footnote" id="footnote-Paluš2008"><a class="tag is-link" href="#citeref-Paluš2008">Paluš2008</a>Paluš, Milan (2008). Bootstrapping Multifractals: Surrogate Data from Random Cascades on Wavelet Dyadic Trees. Physical Review Letters, 101(13), 134101–. doi:10.1103/PhysRevLett.101.134101</li><li class="footnote" id="footnote-Small2001"><a class="tag is-link" href="#citeref-Small2001">Small2001</a>Small et al., Surrogate test for pseudoperiodic time series data, <a href="https://doi.org/10.1103/PhysRevLett.87.188101">Physical Review Letters, 87(18)</a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="man/whatisasurrogate/">Crash-course in timeseries surrogate testing »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Tuesday 12 December 2023 14:23">Tuesday 12 December 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
