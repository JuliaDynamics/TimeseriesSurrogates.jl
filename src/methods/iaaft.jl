export IAAFT
"""
    IAAFT(M = 100, tol = 1e-6, W = 75)

An iteratively adjusted amplitude-adjusted-fourier-transform surrogate[^SchreiberSchmitz1996].

IAAFT surrogate have the same linear correlation, or periodogram, and also
preserves the amplitude distribution of the original data, but are improved relative
to AAFT through iterative adjustment (which runs for a maximum of `M` steps).
During the iterative adjustment, the periodograms of the original signal and the
surrogate are coarse-grained and the powers are averaged over `W` equal-width
frequency bins. The iteration procedure ends when the relative deviation
between the periodograms is less than `tol` (or when `M` is reached).

IAAFT, just as AAFT, can be used to test the null hypothesis that the data 
come from a monotonic nonlinear transformation of a linear Gaussian process.

[^SchreiberSchmitz1996]: T. Schreiber; A. Schmitz (1996). "Improved Surrogate Data for Nonlinearity Tests". [Phys. Rev. Lett. 77 (4)](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.77.635)
"""
struct IAAFT <: Surrogate
    M::Int
    tol::Real
    W::Int

    function IAAFT(;M::Int = 100, tol::Real = 1e-6, W::Int = 75)
        new(M, tol, W)
    end
end

Base.show(io::IO, x::IAAFT) = print(io, "IAAFT(M=$(x.M), tol=$(x.tol), W=$(x.W))")

function surrogenerator(x, method::IAAFT, rng = Random.default_rng())
    # Pre-plan Fourier transforms
    forward = plan_rfft(x)
    inverse = plan_irfft(forward*x, length(x))

    # Pre-compute stuff that can be used for different surrogate realizations
    m = mean(x)
    x_sorted = sort(x)
    𝓕 = forward*(x .- m)
    r_original = abs.(𝓕)

    # Coarse-grain the periodograms when comparing them between iterations.
    px = DSP.periodogram(x)
    range = LinRange(0.0, 0.5, method.W)
    px_binned = interp(px.freq, px.power, range)

    # These are updated during iteration procedure
    𝓕new = Vector{Complex{Float64}}(undef, length(𝓕))
    𝓕sorted = Vector{Complex{Float64}}(undef, length(𝓕))
    ϕsorted = Vector{Complex{Float64}}(undef, length(𝓕))

    init = (forward = forward, inverse = inverse, m = m, 𝓕 = 𝓕, r_original = r_original,
            px_binned = px_binned, range = range, x_sorted = x_sorted,
            𝓕new = 𝓕new, 𝓕sorted =  𝓕sorted, ϕsorted = ϕsorted)

    return SurrogateGenerator(method, x, init, rng)
end

function (sg::SurrogateGenerator{<:IAAFT})()
    init_fields = (:forward, :inverse, :m, :𝓕, :r_original,
                    :px_binned, :range,
                    :x_sorted,
                    :𝓕new, :𝓕sorted, :ϕsorted)
    forward, inverse, m, 𝓕, r_original,
        px_binned, range,
        x_sorted,
        𝓕new, 𝓕sorted, ϕsorted = getfield.(Ref(sg.init), init_fields)

    x = sg.x
    M = sg.method.M
    tol = sg.method.tol

    # Keep track of difference between periodograms between iterations
    diffs = zeros(Float64, 2)

    # RANK ORDERING.
    # Create some Gaussian noise, and find the indices that sorts it with
    # increasing amplitude. Then sort the original time series according to
    # the indices rendering the Gaussian noise sorted.
    n = length(x)
    g = rand(sg.rng, Normal(), n)
    ts_sorted = x[sortperm(g)]

    # The surrogate
    s = Vector{Float64}(undef, n)

    iter = 1
    success = false
    while iter <= M
        # Take the Fourier transform of `ts_sorted` and get the phase angles of
        # the resulting complex numbers.
        𝓕sorted .= forward * ts_sorted
        ϕsorted .= angle.(𝓕sorted)

        # The new spectrum preserves the amplitudes of the Fourier transform of
        # the original time series, but randomises the phases (because the
        # phases are derived from the *randomly sorted* version of the original
        # time series).
        𝓕new .= r_original .* exp.(ϕsorted .* 1im)

        # Now, let the surrogate time series be the values of the original time
        # series, but sorted according to the new spectrum. The shuffled series
        # is generated by taking the inverse Fourier transform of the spectrum
        # consisting of the original amplitudes, but having randomised phases.
        s .= real.(inverse * 𝓕new) # ifft normalises by default

        # map original values onto shuffle
        s[sortperm(s)] = x_sorted
        ts_sorted .= s

        # Convergence check on periodogram
        ps = DSP.periodogram(s)
        ps_binned = interp(ps.freq, ps.power, range)

        if iter == 1
            diffs[1] = sum((px_binned[2] .- ps_binned[2]).^2) / sum(px_binned[2].^2)
        else
            diffs[2] = sum((px_binned[2] .- ps_binned[2]).^2) / sum(px_binned[2].^2)
            abs(diffs[1] - diffs[2]) < tol ? break : diffs[1] = copy(diffs[2])
        end

        iter += 1
    end

    return s
end


include("../utils/powerspectrum.jl")
export IAAFT2

struct IAAFT2 <: Surrogate
    M::Int
    tol::Real
    W::Int

    function IAAFT2(;M::Int = 100, tol::Real = 1e-6, W::Int = 75)
        new(M, tol, W)
    end
end

Base.show(io::IO, x::IAAFT2) = print(io, "IAAFT2(M = $(x.M), tol = $(x.tol), W = $(x.W))")

using Interpolations
getrange(t, n) = LinRange(minimum(t), maximum(t), n)
itp(x) = LinearInterpolation(1:length(x), x)
interp(itp, tᵢ) = itp()

function interpolated_spectrum(spectrum, n)
    intp_spectrum = zeros(n)
    interpolated_spectrum!(intp_spectrum, spectrum, n)
end

function interpolated_spectrum!(intp_spectrum, spectrum, n)
    t = 1:length(spectrum)
    r = getrange(t, n)
    iₓ = itp(spectrum)
    intp_spectrum .= iₓ.(r)
    return intp_spectrum
end

function surrogenerator(x, method::IAAFT2, rng = Random.default_rng())
    m = mean(x)

    # Pre-plan Fourier transforms
    forward = plan_rfft(x)
    inverse = plan_irfft(forward * x, length(x))

    # Initial forward transform.
    𝓕 = forward * x

    # Amplitudes of the initial transform are kept 
    # constant during iterations, so pre-allocate.
    r = abs.(𝓕)

    # Pre-allocate angles (these change during iteration)
    ϕ = abs.(𝓕)

    # Sorted values of the original time series are used for the rescaling step.
    x̂ = sort(x)

    # Initial power spectrum
    xpower = prepare_spectrum(x)
    powerspectrum_onesided!(xpower, x, forward)
    xpowerbinned = interpolated_spectrum(xpower, method.W)
    spowerbinned = interpolated_spectrum(xpower, method.W)

    init = (
        forward = forward, 
        inverse = inverse, 
        𝓕 = 𝓕, 
        r = r, 
        ϕ = ϕ, 
        m = m, 
        x̂ = x̂, 
        xpower = xpower, 
        xpowerbinned = xpowerbinned,
        spowerbinned = spowerbinned,
    )

    return SurrogateGenerator2(method, x, similar(x), init, rng)
end

using Plots
function (sg::SurrogateGenerator2{<:IAAFT2})()
    init_fields = (:forward, :inverse, :𝓕, :r, :ϕ, :m, :x̂, :xpower, :xpowerbinned, :spowerbinned)
    forward, inverse, 𝓕, r, ϕ, m, x̂, xpower, xpowerbinned, spowerbinned = getfield.(Ref(sg.init), init_fields)

    x, s, rng = sg.x, sg.s, sg.rng
    M, W = sg.method.M, sg.method.W
    tol = sg.method.tol

    # Pre-allocate surrogate periodogram
    spower = copy(xpower)

    # Keep track of difference between periodograms between iterations
    diffs = zeros(Float64, 2)

    # Surrogate starts out as a random permutation of `x`
    n = length(x)
    s .= x[sample(rng, 1:n, n)]

    # Index vector used to sort in-place
    ix = zeros(Int, length(x))

    iter = 1
    while iter <= M        
        # Fourier transform of the surrogate. 
        𝓕 .= forward * s
        ϕ .= angle.(𝓕)
        
        # Replace amplitudes of the transform with the original amplitudes `r𝓕`,
        # leavding phases untouched.
        𝓕 .= r .* exp.(ϕ .* 1im)

        # The surrogate is initially the real part of the inverse transform.
        s .= inverse * 𝓕

        # The inverse transform does not preserve the original values of the time series, 
        # because the phases are randomized. We therefore rank-order `s` (sort it), 
        # and replace its value with the sorted `x` values.
        sortperm!(ix, s)
        s[ix] .= x̂

        # Compute periodogram for the current state of the surrogate `s`
        powerspectrum_onesided!(spower, s, forward)
        interpolated_spectrum!(spowerbinned, spower, W)

        # Convergence check on periodogram using relative discrepancy criterion 
        # from the paper.
        if iter == 1
            diffs[1] = sum((xpowerbinned .- xpowerbinned) .^ 2) / sum(xpowerbinned .^ 2)
        else
            diffs[2] = sum((xpowerbinned .- spowerbinned) .^ 2) / sum(xpowerbinned .^ 2)
            abs(diffs[1] - diffs[2]) < tol ? break : diffs[1] = copy(diffs[2])
        end

        iter += 1
    end
    return s
end
