export TFTS, TAAFT

"""
    TFTS(fœµ::Real)

A truncated Fourier transform surrogate[^Nakamura2006] (TFTS).

TFTS surrogates are generated by leaving some frequencies untouched when performing the
phase shuffling step (as opposed to randomizing all frequencies, like for
[`RandomFourier`](@ref) surrogates).

These surrogates were designed to deal with data with irregular fluctuations superimposed
over long term trends (by preserving low frequencies)[^Nakamura2006]. Hence, TFTS surrogates
can be used to test the null hypothesis that the signal is a stationary linear system
generated the irregular fluctuations part of the signal[^Nakamura2006].

## Controlling the truncation of the spectrum

The truncation parameter `fœµ ‚àà [-1, 0) ‚à™ (0, 1]` controls which parts of the spectrum are preserved.

- If `fœµ > 0`, then `fœµ` indicates the ratio of high frequency domain to the entire frequency domain.
    For example, `fœµ = 0.5` preserves 50% of the frequency domain (randomizing the higher
    frequencies, leaving low frequencies intact).
- If `fœµ < 0`, then `fœµ` indicates ratio of low frequency domain to the entire frequency domain.
    For example, `fœµ = -0.2` preserves 20% of the frequency domain (leaving higher frequencies intact,
    randomizing the lower frequencies).
- If `fœµ ¬± 1`, then all frequencies are randomized. The method is then equivalent to
    [`RandomFourier`](@ref).

The appropriate value of `fœµ` strongly depends on the data and time series length, and must be
manually determined[^Nakamura2006], for example by comparing periodograms for the time series and
the surrogates.

[^Nakamura2006]: Nakamura, Tomomichi, Michael Small, and Yoshito Hirata. "Testing for nonlinearity in irregular fluctuations with long-term trends." Physical Review E 74.2 (2006): 026205.
"""
struct TFTS <: Surrogate
    fœµ::Real

    function TFTS(fœµ::Real)
        if !(0 < fœµ ‚â§ 1) && !(-1 ‚â§ fœµ < 0)
            throw(ArgumentError("`fœµ` must be on the interval [-1, 0) ‚à™ (0, 1] (positive if preserving high frequencies, negative if preserving low frequencies)"))
        end
        new(fœµ)
    end
end

function surrogenerator(x, method::TFTS, rng = Random.default_rng())
    # Pre-plan Fourier transforms
    forward = plan_rfft(x)
    inverse = plan_irfft(forward*x, length(x))

    # Pre-compute ùìï
    ùìï = forward * x

    # Polar coordinate representation of the Fourier transform
    rx = abs.(ùìï)
    œïx = angle.(ùìï)
    n = length(ùìï)

    # These are updated during iteration procedure
    ùìïnew = Vector{Complex{Float64}}(undef, length(ùìï))
    ùìïs = Vector{Complex{Float64}}(undef, length(ùìï))
    œïs = Vector{Complex{Float64}}(undef, length(ùìï))

    init = (forward = forward, inverse = inverse,
        rx = rx, œïx = œïx, n = n,
        ùìïnew = ùìïnew, ùìïs = ùìïs, œïs = œïs)

    return SurrogateGenerator(method, x, similar(x), init, rng)
end

function (sg::SurrogateGenerator{<:TFTS})()
    x, s = sg.x, sg.s
    fœµ = sg.method.fœµ
    L = length(x)

    init_fields = (:forward, :inverse,
        :rx, :œïx, :n,
        :ùìïnew, :ùìïs, :œïs)

    forward, inverse,
        rx, œïx, n,
        ùìïnew, ùìïs, œïs = getfield.(Ref(sg.init), init_fields)

    # Surrogate starts out as a random permutation of x
    s .= x[StatsBase.sample(sg.rng, 1:L, L; replace = false)]
    ùìïs .= forward * s
    œïs .= angle.(ùìïs)

    # Updated spectrum is the old amplitudes with the mixed phases.
    if fœµ > 0
        # Frequencies are ordered from lowest when taking the Fourier
        # transform, so by keeping the 1:n_ni first phases intact,
        # we are only randomizing the high-frequency components of the
        # signal.
        n_preserve = ceil(Int, abs(fœµ * n))
        œïs[1:n_preserve] .= œïx[1:n_preserve]
    elseif fœµ < 0
        # Do the exact opposite to preserve high-frequencies
        n_preserve = ceil(Int, abs(fœµ * n))
        œïs[end-n_preserve+1:end] .= œïx[end-n_preserve+1:end]
    end

    ùìïnew .= rx .* exp.(œïs .* 1im)
    s .= inverse * ùìïnew
    
    return s
end

"""
    TAAFT(fœµ)

An truncated version of the amplitude-adjusted-fourier-transform surrogate[^Theiler1991][^Nakamura2006].

The truncation parameter and phase randomization procedure is identical to [`TFTS`](@ref), but here an
additional step of rescaling back to the original data is performed. This preserves the
amplitude distribution of the original data.

[^Theiler1991]: J. Theiler, S. Eubank, A. Longtin, B. Galdrikian, J. Farmer, Testing for nonlinearity in time series: The method of surrogate data, Physica D 58 (1‚Äì4) (1992) 77‚Äì94.
[^Nakamura2006]: Nakamura, Tomomichi, Michael Small, and Yoshito Hirata. "Testing for nonlinearity in irregular fluctuations with long-term trends." Physical Review E 74.2 (2006): 026205.
"""
struct TAAFT <: Surrogate
    fœµ::Real

    function TAAFT(fœµ::Real)
        fœµ != 0 || throw(ArgumentError("`fœµ` must be on the interval [-1, 0) ‚à™ (0, 1] (positive if preserving high frequencies, negative if preserving low frequencies)"))
        new(fœµ)
    end
end

function surrogenerator(x, method::TAAFT, rng = Random.default_rng())
    init = (
        gen = surrogenerator(x, TFTS(method.fœµ), rng),
        x_sorted = sort(x),
    )
    
    s = similar(x)
    return SurrogateGenerator(method, x, s, init, rng)
end

function (taaft::SurrogateGenerator{<:TAAFT})()
    sg = taaft.init.gen
    x_sorted = taaft.init.x_sorted
    
    x, s = sg.x, sg.s
    fœµ = sg.method.fœµ
    L = length(x)

    init_fields = (:forward, :inverse,
        :rx, :œïx, :n,
        :ùìïnew, :ùìïs, :œïs)

    forward, inverse,
        rx, œïx, n,
        ùìïnew, ùìïs, œïs = getfield.(Ref(sg.init), init_fields)

    # Surrogate starts out as a random permutation of x
    s .= x[StatsBase.sample(sg.rng, 1:L, L; replace = false)]
    ùìïs .= forward * s
    œïs .= angle.(ùìïs)

    # Updated spectrum is the old amplitudes with the mixed phases.
    if fœµ > 0
        # Frequencies are ordered from lowest when taking the Fourier
        # transform, so by keeping the 1:n_ni first phases intact,
        # we are only randomizing the high-frequency components of the
        # signal.
        n_preserve = ceil(Int, abs(fœµ * n))
        #println("Preserving $(n_preserve/n*100) % of the frequencies (randomizing high frequencies)")
        œïs[1:n_preserve] .= œïx[1:n_preserve]
    elseif fœµ < 0
        # Do the exact opposite to preserve high-frequencies
        n_preserve = ceil(Int, abs(fœµ * n))
        #println("Preserving $(n_preserve/n*100) % of the frequencies (randomizing low frequencies)")
        œïs[end-n_preserve+1:end] .= œïx[end-n_preserve+1:end]
    end

    ùìïnew .= rx .* exp.(œïs .* 1im)
    s .= inverse * ùìïnew
    
    s = sg()
    s[sortperm(s)] .= x_sorted
    return s
end


