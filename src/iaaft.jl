"""
    iaaft(ts::AbstractArray{T, 1} where T;
            n_maxiter = 200, tol = 1e-6, n_windows = 50)

Generate an iteratively adjusted amplitude adjusted Fourier transform (IAAFT)
([Schreiber & Schmitz, 1996](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.77.635))
surrogate realization of `ts`.

## Arguments

- **`ts`**: the time series for which to generate an AAFT surrogate realization.

- **`n_maxiter`**: sets the maximum number of iterations to allow before ending
    the algorithm (if convergence is slow).

- **`tol`**: the relative tolerance for deciding if convergence is achieved.

- **`n_window`**: the number is windows used when binning the periodogram (used
    for determining convergence).

## References

T. Schreiber; A. Schmitz (1996). "Improved Surrogate Data for Nonlinearity
Tests". Phys. Rev. Lett. 77 (4): 635–638. doi:10.1103/PhysRevLett.77.635.
PMID 10062864. [https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.77.635](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.77.635)

"""
function iaaft(ts::AbstractVector{T} where T;
                n_maxiter = 200, tol = 1e-6, n_windows = 50)
    any(isnan.(ts)) && throw(DomainError(NaN,"The input must not contain NaN values."))
	
    # Sorted version of the original time series
    original_sorted = sort(ts)

    # Fourier transform and its amplitudes
    original_fft = fft(ts)
    original_fft_amplitudes = abs.(original_fft)

    # RANK ORDERING.
    # Create some Gaussian noise, and find the indices that sorts it with
    # increasing amplitude. Then sort the original time series according to
    # the indices rendering the Gaussian noise sorted.
    n = length(ts)
    g = rand(Normal(), n)
    inds = sortperm(g)
    ts_sorted = ts[inds]

    iter = 1
    success = false

    spectrum = Vector{Complex{Float64}}(undef, n)
    surrogate = Vector{Float64}(undef, n)

    diffs = zeros(Float64, 2)
    while iter <= n_maxiter
        # Take the Fourier transform of `ts_sorted` and get the phase angles of
        # the resulting complex numbers.
        FT = fft(ts_sorted)
        phase_angles = angle.(FT)

        # The new spectrum preserves the amplitudes of the Fourier transform of
        # the original time series, but randomises the phases (because the
        # phases are derived from the *randomly sorted* version of the original
        # time series).
        spectrum[:] = original_fft_amplitudes .* exp.(phase_angles .* 1im)

        # Now, let the surrogate time series be the values of the original time
        # series, but sorted according to the new spectrum. The shuffled series
        # is generated by taking the inverse Fourier transform of the spectrum
        # consisting of the original amplitudes, but having randomised phases.
        surrogate[:] = real(ifft(spectrum)) # ifft normalises by default

        # map original values onto shuffle
        surrogate[sortperm(surrogate)] = original_sorted

        ts_sorted[:] = surrogate

        # Convergence check
        periodogram = DSP.mt_pgram(ts)
        periodogram_surr = DSP.mt_pgram(surrogate)

        power_binned = interp([x for x in periodogram.freq],
                            periodogram.power,
                            n_windows)

        power_binned_surr = interp([x for x in periodogram_surr.freq],
                            periodogram_surr.power,
                            n_windows)

        if iter == 1
            diffs[1] = sum((power_binned[2] .- power_binned_surr[2]).^2) /
                        sum(power_binned[2].^2)
        else
            diffs[2] = sum((power_binned[2] .- power_binned_surr[2]).^2) /
                        sum(power_binned[2].^2)
            if abs(diffs[1] - diffs[2]) < tol
                break
            end
            diffs[1] = copy(diffs[2])
        end

        iter += 1
    end
    surrogate
end


"""
    iaaft_iters(ts::AbstractArray{T, 1} where T;
                n_maxiter = 100, tol = 1e-5, n_windows = 50)

Generate an iteratively adjusted amplitude adjusted Fourier transform (IAAFT) [1]
surrogate series for `ts` and return a vector containing the surrogate series
from each iteration. The last vector contains the final surrogate.

# Literature references
1. T. Schreiber; A. Schmitz (1996). "Improved Surrogate Data for Nonlinearity
Tests". Phys. Rev. Lett. 77 (4): 635–638. doi:10.1103/PhysRevLett.77.635. PMID
10062864.
"""
function iaaft_iters(ts::AbstractArray{T, 1} where T;
                        n_maxiter = 100, tol = 1e-5, n_windows = 50)

    # Sorted version of the original time series
    original_sorted = sort(ts)

    # Fourier transform and its amplitudes
    original_fft = fft(ts)
    original_fft_amplitudes = abs.(original_fft)

    # Create some Gaussian noise, and find the indices that sorts it with
    # increasing amplitude. Then sort the original time series according to the
    # indices rendering the Gaussian noise sorted.
    n = length(ts)
    g = rand(Normal(), n)
    inds = sortperm(g)
    ts_sorted = ts[inds]

    iter = 1
    success = false

    spectrum = Vector{Complex{Float64}}(undef, n)
    surrogate = Vector{Float64}(undef, n)
    surrogates = Vector{Vector{Float64}}(undef, 0)

    diffs = zeros(Float64, 2)
    while iter <= n_maxiter
        # Take the Fourier transform of `ts_sorted` and get the phase angles
        # of the resulting complex numbers.
        ts_sorted_fft = fft(ts_sorted)
        phase_angles = angle.(ts_sorted_fft)

        # The new spectrum preserves the amplitudes of the Fourier transform
        # of the original time series, but randomises the phases (because the
        # phases are derived from the *randomly sorted* version of the original
        # time series).
        spectrum .= original_fft_amplitudes .* exp.(phase_angles .* 1im)

        # Now, let the surrogate time series be the values of the original time
        # series, but sorted according to the new spectrum. The shuffled series
        # is generated by taking the inverse Fourier transform of the spectrum
        # consisting of the original amplitudes, but having randomised phases.
        surrogate[:] = real(ifft(spectrum)) # ifft normalises by default
        surrogate[sortperm(surrogate)] = original_sorted # map original values onto shuffle
        push!(surrogates, surrogate[:])

        ts_sorted .= surrogate

        # Convergence check
        periodogram = DSP.mt_pgram(ts)
        periodogram_surr = DSP.mt_pgram(surrogate)

        power_binned = interp([x for x in periodogram.freq],
                                periodogram.power,
                                n_windows)

        power_binned_surr = interp([x for x in periodogram_surr.freq],
                                    periodogram_surr.power,
                                    n_windows)

        if iter == 1
            diffs[1] = sum((power_binned[2] .- power_binned_surr[2]).^2) /
                        sum(power_binned[2].^2)
        else
            diffs[2] = sum((power_binned[2] .- power_binned_surr[2]).^2) /
                        sum(power_binned[2].^2)

            if abs(diffs[1] - diffs[2]) < tol
                break
            end
            diffs[1] = copy(diffs[2])
        end

        iter += 1
    end
    surrogates
end

export iaaft, iaaft_iters
